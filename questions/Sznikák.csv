1;;4;;Mi a futtatókörnyezet (runtime) egyik alapvető funkciója a diák alapján?;;Hardvereszközök közvetlen kezelése;;Egy absztrakt számítógép-architektúra (VM) biztosítása;;Forráskód fordítása tetszőleges nyelvre;;A felhasználói felület elemeinek megjelenítése;;B;;Futtatókörnyezetek
2;;5;;Milyen előnyt jelent a köztes nyelv (IL) használata a hordozhatóság szempontjából?;;Minden platformra külön natív fordítót kell írni;;Az n*m probléma helyett n+m fordítóra van szükség;;A köztes nyelv közvetlenül fut a processzoron;;A kód mérete minden esetben a felére csökken;;B;;Futtatókörnyezetek
3;;6;;Mikor történik a köztes kódról natív kódra fordítás a hatékonyság maximalizálása érdekében?;;A forráskód írásával egy időben;;A program telepítésekor a célgépen;;A lehető legkésőbbi pillanatban, a végleges környezetben;;Minden programindítás előtt, teljes egészében;;C;;Futtatókörnyezetek
4;;5;;Melyik NEM tartozik a futtatókörnyezetek által nyújtott biztonsági funkciók közé?;;Automatikus szemétgyűjtés a memóriaszivárgás ellen;;Futás közbeni hibák azonnali megfogása;;Tetszőleges pointer-aritmetika engedélyezése;;Adat- és kódellenőrzés a futtatás során;;C;;Futtatókörnyezetek
5;;4;;Milyen típusú kódot generál a Java fordító a forráskódból?;;IL (Intermediate Language) kódot;;Natív, processzor-specifikus kódot;;Bytecode-ot, amit a JVM futtat;;C++ forráskódot a maximális sebességért;;C;;Futtatókörnyezetek
6;;4;;Mi a Java "Write once, run/debug anywhere" elvének alapja?;;A közös grafikus felület szabványa;;A portolhatóság, melyet a JVM biztosít;;Az ingyenesen elérhető fejlesztői eszközök;;Az automatikus memória menedzsment;;B;;Futtatókörnyezetek
7;;5;;Melyik komponens NEM része a Java Virtuális Gép (JVM) belső felépítésének a bemutatott ábrán?;;Classloader (osztálybetöltő);;Verifier (kódellenőrző);;Garbage Collector (szemétgyűjtő);;Execution (végrehajtó motor);;C;;Futtatókörnyezetek
8;;6;;Melyik technológia biztosítja a Java-ban az automatikus memória menedzsmentet?;;A "Nincs pointer!" elv szigorú betartása;;A compile-time típusellenőrzés;;A Garbage Collector (GC) működése;;A beépített szálkezelési modell;;C;;Futtatókörnyezetek
9;;4;;Melyik két fő részből áll a .NET platform alapvető szerkezete?;;Application és Operating System;;Common Language Runtime (CLR) és Base Class Library (BCL);;JIT fordító és NuGet csomagkezelő;;Windows Forms és ASP.NET Core;;B;;Futtatókörnyezetek
10;;5;;Mi a Base Class Library (BCL) elsődleges szerepe a .NET ökoszisztémában?;;A köztes kód (IL) futtatása és menedzselése;;Alapvető osztálykönyvtárak biztosítása (pl. string, file);;Külső, harmadik féltől származó csomagok kezelése;;A kód natívvá fordítása futás közben;;B;;Futtatókörnyezetek
11;;5;;Melyik .NET technológia szolgál webes frontend alkalmazások készítésére az előadás szerint?;;Entity Framework Core;;Windows Presentation Foundation (WPF);;ASP.NET Core vagy Blazor;;ADO.NET adatkezelő;;C;;Futtatókörnyezetek
12;;6;;Mi a legfőbb különbség a régi .NET Framework és a modern .NET (.NET 5+) között?;;A .NET Framework támogatja a C# nyelvet, a .NET nem;;A .NET Framework cross-platform, a modern .NET csak Windows;;A .NET Framework Windows-specifikus, a modern .NET cross-platform;;A modern .NET nem tartalmaz szemétgyűjtőt;;C;;Futtatókörnyezetek
13;;7;;Mi a .NET Standard pontos funkciója?;;Egy konkrét, futtatható .NET implementáció;;Egy szabvány, ami a forráskód-hordozhatóságot segíti;;A .NET Framework és a .NET Core egy közös verziója;;Egy eszköz a Unity játékfejlesztéshez;;B;;Futtatókörnyezetek
14;;5;;Melyik a CLR (Common Language Runtime) egyik legfontosabb tervezési szempontja?;;Kizárólag egy programnyelv (C#) támogatása;;A korábbi technológiáktól való teljes elzárkózás;;Több programnyelv támogatása és integrációja;;A manuális memóriakezelés megkövetelése;;C;;Futtatókörnyezetek
15;;6;;Mi a Common Type System (CTS) szerepe a .NET-ben?;;A nyelvek közötti típuskompatibilitás biztosítása;;A közös szintaktikai szabályok definiálása;;A szemétgyűjtő algoritmusának meghatározása;;A kivételkezelés egységesítése;;A;;Futtatókörnyezetek
16;;6;;Melyik NEM a CLR komponense a bemutatott ábra alapján?;;Szálkezelő (Thread Manager);;IL -> Natív JIT-fordító;;Roslyn fordító platform;;COM Marshaler;;C;;Futtatókörnyezetek
17;;5;;Mit jelent az, hogy a .NET nyelvfüggetlen?;;Minden .NET nyelvet ugyanaz a fordító fordít;;A keretrendszer szolgáltatásai minden nyelv számára elérhetőek;;Kizárólag a C# nyelvvel lehet elérni a CLR funkcióit;;A különböző nyelveken írt kódok nem keverhetőek;;B;;Futtatókörnyezetek
18;;7;;Melyik az egyetlen nyelv a diák szerint, ahol a natív és felügyelt kód keveredhet?;;A C#, a .NET fő programozási nyelve;;A Visual Basic .NET (VB.NET);;A felügyelt C++ (managed C++);;Az F#, a funkcionális programnyelv;;C;;Futtatókörnyezetek
19;;4;;Mire cseréli le a C# a C++-ban megszokott mutatókat (pointereket)?;;Kizárólag érték szerinti típusátadásra;;Referenciákra, a biztonságosabb memóriakezelésért;;Speciális, "unsafe" kontextusra mindenhol;;Globális változók használatára;;B;;Futtatókörnyezetek
20;;6;;Mi a felügyelt adatok (managed data) legfőbb jellemzője a .NET-ben?;;Minden objektumot manuálisan kell felszabadítani;;Nincs automatikus élettartam-felügyelet;;Minden .NET objektumot a GC (Garbage Collector) takarít el;;A 'delete' utasítás használata kötelező;;C;;Futtatókörnyezetek
21;;7;;Hogyan működik a .NET szemétgyűjtőjének "mark & compact" fázisa?;;Megjelöli és azonnal törli az objektumokat, megszámolja a referenciákat;;Megjelöli az élő objektumokat, majd a memóriát tömöríti;;Csak megjelöli a felesleges objektumokat, de nem törli őket;;Tömöríti a memóriát, majd ellenőrzi a hivatkozásokat;;B;;Futtatókörnyezetek
22;;6;;Mi a Large Object Heap (LOH) egyik hátránya vagy speciális jellemzője?;;A rajta lévő objektumokat a GC nem tömöríti;;Kizárólag kis méretű objektumok tárolására szolgál;;Determinisztikus és rendkívül gyors a takarítása;;Minden programindításkor teljesen kiürül;;A;;Futtatókörnyezetek
23;;4;;Mi a felügyelt kód (managed code) egyik legfontosabb tulajdonsága?;;Lehetővé teszi a tetszőleges, nem biztonságos típuskonverziót;;Nem ellenőrzi a tömbök indexhatárait;;Szigorú típusellenőrzésnek vethető alá;;Nem képes kezelni a futásidejű kivételeket;;C;;Futtatókörnyezetek
24;;5;;Milyen lépésekből áll a .NET fordítási és végrehajtási folyamata?;;Forráskód -> Natív kód -> Végrehajtás;;Forráskód -> IL -> Interpretálás;;Forráskód -> Nyelvi fordító (IL) -> JIT fordító (Natív);;Forráskód -> JIT fordító -> Végrehajtás;;C;;Futtatókörnyezetek
25;;5;;Mit tartalmaz egy .NET szerelvény (assembly) a köztes kód (IL) mellett?;;A teljes forráskódot .cs vagy .vb formában;;Az operációs rendszerre vonatkozó drivereket;;Metaadatokat a szerelvényről és a benne lévő típusokról;;Egy előre lefordított natív másolatot minden platformra;;C;;Futtatókörnyezetek
26;;6;;Mikor történik meg a JIT (Just-In-Time) fordítás egy adott metódusra?;;A program legelső indításakor az összes metódusra;;A szerelvény (assembly) buildelése során;;A metódus legelső meghívásakor a futás során;;Minden egyes alkalommal, amikor a metódust meghívják;;C;;Futtatókörnyezetek
27;;4;;Mi a .NET szerelvény (assembly) elsődleges szerepe?;;A forráskód logikai csoportosítása névterekbe;;A telepítés, verziókezelés és újrafelhasználás egysége;;Egy ideiglenes fájl a fordítási folyamat során;;Egy konfigurációs fájl a futtatókörnyezet számára;;B;;Futtatókörnyezetek
28;;6;;Mi a szerelvény-referenciák egyik legfontosabb szabálya a körkörös függőségek elkerülésére?;;A referencia mindig kétirányú kell, hogy legyen;;Egy .exe fájl nem hivatkozhat .dll fájlra;;A referenciának egyirányúnak kell lennie (függőségi fa);;Bármelyik szerelvény hivatkozhat bármelyik másikra;;C;;Futtatókörnyezetek
29;;5;;Mire szolgál a NuGet a .NET ökoszisztémában?;;A .NET keretrendszer belső komponenseinek kezelésére;;A forráskód verziókövetésére (mint a Git);;Egy csomagkezelő, külső könyvtárak beillesztésére;;A C# kód IL kódra való fordítására;;C;;Futtatókörnyezetek
30;;6;;A szemantikus verziózás (Semantic Versioning) szerint mit jelez a MAJOR szám változása (pl. 2.1 -> 3.0)?;;Kompatibilitástörő változást, ami a régi kódot elronthatja;;Egy új, de visszafelé kompatibilis funkció hozzáadását;;Egy kisebb hibajavítást vagy szervizcsomagot;;A build sorszámának egyszerű növekedését;;A;;Futtatókörnyezetek
31;;6;;Milyen telepítési modellt részesít előnyben a modern .NET (.NET Core és .NET 5+)?;;"Shared" (megosztott), ahol a DLL-ek egy központi GAC mappában vannak;;"Private" (privát), ahol a DLL-ek az alkalmazás mappájában vannak;;Online telepítést, ahol a DLL-ek futás közben töltődnek le;;"Hybrid" (hibrid), ahol a DLL-ek fele privát, fele megosztott;;B;;Futtatókörnyezetek
32;;7;;Mi a klasszikus "DLL Hell" probléma lényege?;;Amikor egy DLL fájl túl naggyá válik a betöltéshez;;Amikor egy központi mappában lévő DLL-t felülír egy inkompatibilis verzió;;Amikor a fejlesztő elfelejt hivatkozni egy szükséges DLL-re;;Amikor egy DLL fájl vírusos fertőzést kap;;B;;Futtatókörnyezetek
33;;5;;Egy Visual Studio solution-ben hogyan a legcélszerűbb megoldani, hogy egy "App.exe" projekt használja egy "Library.dll" projekt kódját?;;Az "App.exe" projektben szerelvény referenciát adunk a "Library.dll" fájlra;;Mindkét projektet egy közös NuGet csomagba tesszük;;Az "App.exe" projektben projekt referenciát adunk a "Library.dll" projekthez;;A "Library.dll" forráskódját átmásoljuk az "App.exe" projektbe;;C;;Futtatókörnyezetek
34;;5;;Melyik réteg található közvetlenül az alkalmazás (Application) és az operációs rendszer (Operating System) között a bemutatott architektúrában?;;A hardver absztrakciós réteg;;A felhasználói felület (UI) rétege;;A futtatókörnyezet (Runtime);;A hálózati kommunikációs réteg;;C;;Futtatókörnyezetek
35;;7;;Mi a fő oka annak, hogy a felügyelt C++-t "Total Control"-nak is nevezik a diák kontextusában?;;Mert ez az egyetlen nyelv, ami a leggyorsabban fut;;Mert ez az egyetlen nyelv, ahol a natív és felügyelt kód/adat keveredhet;;Mert a Microsoft ezt a nyelvet fejleszti a legaktívabban;;Mert teljes kontrollt ad a felhasználói felület felett;;B;;Futtatókörnyezetek
1;;5;;Mi a viszony az 'int' és a 'System.Int32' között C#-ban?;;Az 'int' egy érték típus, míg a 'System.Int32' egy referencia típus;;Az 'int' a C# nyelv aliasa a .NET-es System.Int32 típusra;;Az 'int' egy ősosztálya a System.Int32-nek, több funkcionalitással;;A System.Int32 használata lassabb, mert az egy teljes értékű objektum;;B;;Nyelvi eszközök EA
2;;6;;Melyik állítás igaz a System.Object típusra C#-ban?;;Csak a referencia típusok származnak a System.Object-ből implicit módon;;Még az elemi típusok, mint az int vagy double is, implicit módon belőle származnak;;A System.Object egy interfész, amit minden osztálynak implementálnia kell;;A felhasználónak expliciten kell örököltetnie minden osztályt a System.Object-ből;;B;;Nyelvi eszközök EA
3;;4;;Hol jönnek létre az érték típusok (pl. struct) és a referencia típusok (pl. class) példányai?;;Mindkét típusú objektum a heap-en jön létre a 'new' kulcsszóval;;Az érték típusok a heap-en, a referencia típusok a vermen (stack) jönnek létre;;Az érték típusok a vermen (stack), a referencia típusok a heap-en jönnek létre;;Mindkét típusú objektum a vermen (stack) jön létre a gyors elérés érdekében;;C;;Nyelvi eszközök EA
4;;6;;Mi az érték típusok (value types) használatának egyik legjelentősebb előnye?;;Nem kell a Garbage Collectornak (GC) takarítania őket, ami teljesítménynövekedést okoz;;Bonyolult objektumhierarchiák és öröklési láncok hozhatók létre velük;;Mindig referenciaként adódnak át, így nem kell őket másolni;;Automatikusan rendelkeznek szinkronizációs mechanizmusokkal;;A;;Nyelvi eszközök EA
5;;6;;Melyik korlátozás vonatkozik a 'struct'-okra a C# nyelvben?;;Nem implementálhatnak interfészeket, ellentétben az osztályokkal;;Nem lehetnek tagfüggvényeik, csak adattagjaik lehetnek;;Nem lehet belőlük örökölni, és ők sem örökölhetnek más osztályoktól;;Nem használhatók generikus kollekciókban a másolódásuk miatt;;C;;Nyelvi eszközök EA
6;;7;;Miben különbözik a C# 'struct' kulcsszava a C++ 'struct' kulcsszavától az alapértelmezett láthatóság terén?;;A C# struct tagjai alapértelmezetten public, míg a C++-ban private;;A C#-ban nincs különbség, mindkettőben alapértelmezetten public;;A C# struct tagjai alapértelmezetten private, mint a C# class-oké;;A C# struct nem egy class, ellentétben a C++ struct-tal;;D;;Nyelvi eszközök EA
7;;5;;Mi történik, amikor egy 'string' típusú változó tartalmát módosítjuk C#-ban?;;A művelet egy új string példányt hoz létre a memóriában az új tartalommal;;A meglévő string objektum tartalma módosul a memóriában (in-place);;A fordító hibát jelez, mivel a stringek konstansok és nem módosíthatók;;A string automatikusan egy StringBuilder objektummá konvertálódik;;A;;Nyelvi eszközök EA
8;;6;;Miért nem javasolt a '+' operátor használata stringek összefűzésére egy cikluson belül?;;Mert a '+' operátor ciklusban való használata fordítási hibát okoz;;Mert minden egyes összefűzés új, ideiglenes string objektumot hoz létre;;Mert a stringek maximális hossza korlátozott, és a ciklus túllépheti azt;;Mert a veremtúlcsordulás (stack overflow) veszélye fennáll;;B;;Nyelvi eszközök EA
9;;4;;Melyik a két leghatékonyabb, javasolt módszer stringek dinamikus összeállítására?;;A '+' operátor és a String.Join metódus használata;;A String.Concat metódus és a karaktertömbök kezelése;;A StringBuilder osztály és a string interpoláció ($"...") használata;;A String.Format metódus és a reguláris kifejezések alkalmazása;;C;;Nyelvi eszközök EA
10;;4;;Mi az 'enum' (felsorolt típus) elsődleges célja a C# nyelvben?;;Számok helyett nevesített elemek használata a jobb olvashatóságért;;Nagy teljesítményű matematikai számítások elvégzése;;Komplex adatszerkezetek, például láncolt listák létrehozása;;Dinamikus típuskezelés és futásidejű típusellenőrzés;;A;;Nyelvi eszközök EA
11;;7;;Mire szolgál a '[Flags]' attribútum egy 'enum' típus definíciója előtt?;;Azt jelzi, hogy az enum értékei nem kombinálhatók egymással;;Lehetővé teszi, hogy az enum értékeit bitműveletekkel lehessen kombinálni;;Megakadályozza az enum elemeinek szöveggé alakítását a ToString() metódussal;;Azt jelöli, hogy az enum csak lebegőpontos számokat tartalmazhat;;B;;Nyelvi eszközök EA
12;;5;;Melyik NEM egy C# osztály lehetséges tagja az előadás alapján?;;Field (mező), amely egy tagváltozót reprezentál;;Property (tulajdonság), amely get/set metódusokkal éri el az értéket;;Namespace (névtér), amely logikailag csoportosítja az osztályt;;Method (metódus), amely a funkcionalitást implementálja;;C;;Nyelvi eszközök EA
13;;6;;Mire használható egy indexer egy C# osztályban?;;Az osztály egyetlen numerikus értékének beállítására;;A konténer típusú osztály elemeinek indexelt elérésére a [ ] jellel;;Az osztály fizikai memóriacímének lekérdezésére;;Statikus metódusok dinamikus meghívására név alapján;;B;;Nyelvi eszközök EA
14;;7;;Hogyan működik a rövidzár kiértékelés (short-circuit evaluation) a '&&' operátornál?;;Mindkét operandust kiértékeli, függetlenül az első értékétől;;Ha az első operandus 'false', a másodikat már nem értékeli ki;;Ha az első operandus 'true', a másodikat már nem értékeli ki;;Kizárólag egész számok közötti logikai ÉS műveletre használható;;B;;Nyelvi eszközök EA
15;;6;;Melyik operátor NEM definiálható felül C#-ban?;;A '+' aritmetikai operátor két egyedi osztály összeadására;;A '==' relációs operátor két objektum egyenlőségének vizsgálatára;;A '()' függvényhívás operátor az osztály funktorrá tételéhez;;A '=' hozzárendelés operátor;;D;;Nyelvi eszközök EA
16;;4;;Milyen deklarációs szintaxissal hozunk létre egy kétdimenziós (nem beágyazott) tömböt?;;int[] TwoDim egy dimenziós tömb;;int[,] TwoDim kétdimenziós tömb;;int[][] TwoDim tömbök tömbje;;int[2D] TwoDim speciális szintaxis;;B;;Nyelvi eszközök EA
17;;7;;Mi a különbség egy érték típusú és egy referencia típusú elemeket tartalmazó tömb létrehozása között?;;Semmi, a fordító mindkét esetben ugyanazt a kódot generálja;;Érték típusnál csak a hely jön létre, referencia típusnál a hely és az objektumok is;;Érték típusnál a hely és az elemek is létrejönnek, referencia típusnál csak a referenciák helye;;Referencia típusú tömböt nem lehet létrehozni, csak listát;;C;;Nyelvi eszközök EA
18;;5;;Melyik láthatósági módosító teszi lehetővé az elérést csak az adott szerelvényen (assembly) belül?;;A 'public', amely mindenki számára láthatóvá teszi;;A 'private', amely csak az osztályon belüli elérést engedi;;Az 'internal', amely szerelvényen belüli publikus elérést biztosít;;A 'protected', amely a leszármazottak számára teszi elérhetővé;;C;;Nyelvi eszközök EA
19;;6;;Melyik kulcsszót kell használni egy ősosztálybeli virtuális függvény felülírásához egy leszármazottban?;;A 'virtual' kulcsszót a leszármazottban is;;Az 'override' kulcsszót, jelezve a felülírás szándékát;;A 'new' kulcsszót a metódus elrejtésére;;Az 'abstract' kulcsszót a konkrét implementációhoz;;B;;Nyelvi eszközök EA
20;;6;;Mi a különbség az 'as' és a hagyományos (zárójeles) cast között?;;Az 'as' operátor gyorsabb, de csak referencia típusokra működik;;Az 'as' kivételt dob sikertelen konverziónál, a cast 'null'-t ad;;A cast kivételt dob sikertelen konverziónál, az 'as' 'null'-t ad vissza;;Nincs különbség, az 'as' csak egy szintaktikai könnyítés;;C;;Nyelvi eszközök EA
21;;6;;Milyen esetben használjuk a 'const' és milyenben a 'readonly' kulcsszót?;;A 'const' futásidejű, a 'readonly' fordításidejű konstans;;A 'const' csak osztályszintű, a 'readonly' lehet példányszintű is;;A 'const' csak referencia típusokra, a 'readonly' csak érték típusokra jó;;A 'const' fordításidejű, míg a 'readonly' értéke futásidőben is meghatározható;;D;;Nyelvi eszközök EA
22;;7;;Mikor hívódik meg egy osztály statikus konstruktora?;;Minden egyes példány létrehozásakor a normál konstruktor előtt;;Az első példány létrehozása vagy az első statikus tag elérése előtt;;A program leállásakor a statikus adatok felszabadítására;;A fejlesztőnek kell manuálisan meghívnia a program elején;;B;;Nyelvi eszközök EA
23;;5;;Mi a 'ref' kulcsszó szerepe egy függvény paraméterlistájában?;;Azt jelzi, hogy a paraméter egy referencia típusú objektum;;Lehetővé teszi, hogy a függvény az eredeti változó értékét módosítsa;;Azt jelöli, hogy a paramétert a függvény nem módosíthatja;;A paraméter opcionálissá tételére szolgál;;B;;Nyelvi eszközök EA
24;;6;;Mi a fő különbség a 'ref' és az 'out' paraméterek között?;;A 'ref' befelé és kifelé, az 'out' csak kifelé szállít adatot;;Az 'out' befelé és kifelé, a 'ref' csak befelé szállít adatot;;A 'ref' változónak nem kell értéket adni hívás előtt, az 'out'-nak igen;;A hívás helyén csak a 'ref' kulcsszót kell kitenni, az 'out'-ot nem;;A;;Nyelvi eszközök EA
25;;7;;Mi történik a "boxing" folyamat során C#-ban?;;Egy referencia típusú objektumot alakít át érték típussá a gyorsabb kezelésért;;Egy érték típust csomagol egy objektumba a heap-en, és bemásolja az értékét;;Egy objektum adatait egy bináris fájlba (dobozba) szerializálja;;Egy függvényhívást csomagol egy delegate objektumba;;B;;Nyelvi eszközök EA
26;;4;;Melyik kulcsszóval kezdődik az a blokk, ami a hibakezelés során mindig lefut, akár volt hiba, akár nem?;;A 'try' blokk, amely a védett kódot tartalmazza;;A 'catch' blokk, amely a kivételeket kapja el;;A 'throw' kulcsszó, amely kivételt dob;;A 'finally' blokk, amely a garantáltan lefutó kódot tartalmazza;;D;;Nyelvi eszközök EA
27;;4;;Mire szolgál a 'namespace' (névtér) a C# kódban?;;A kód fizikai elrendezésére a merevlemezen;;Osztályok és típusok logikai csoportosítására, a névütközések elkerülésére;;A memóriakezelés és a szemétgyűjtés finomhangolására;;Egy adott fájlban lévő kód fordítási egységének definiálására;;B;;Nyelvi eszközök EA
28;;6;;Melyik interfészt kell egy kollekciónak implementálnia, hogy használható legyen a 'foreach' ciklussal?;;Az ICollection interfészt a darabszám lekérdezéséhez;;Az IEnumerable interfészt, amely egy GetEnumerator metódust ír elő;;Az IEnumerator interfészt, amely a MoveNext és Current tagokat tartalmazza;;Az IDisposable interfészt a ciklus végi erőforrás-felszabadításhoz;;B;;Nyelvi eszközök EA
29;;5;;Melyik NEM a System.Object osztály virtuális metódusa az előadás alapján?;;ToString(), a szöveges reprezentációért;;GetHashCode(), a hash kód generálásáért;;Equals(object o), az azonosság vizsgálatáért;;GetType(), a futásidejű típusinformációért;;D;;Nyelvi eszközök EA
30;;5;;Melyik típus alkalmas nagy pontosságú pénzügyi számításokra, elkerülve a lebegőpontos hibákat?;;A 'float' típus, amely 32 bites lebegőpontos szám;;A 'double' típus, amely 64 bites lebegőpontos szám;;A 'decimal' típus, amely 128 bites, fixpontos számábrázolású;;A 'long' típus, amely 64 bites egész szám;;C;;Nyelvi eszközök EA
31;;8;;Melyik láthatósági módosító kombináció teszi elérhetővé egy tagot a tartalmazó szerelvényen belül BÁRHOL, illetve azon kívül CSAK a leszármazottakban?;;A 'public', mert az mindenhol elérhetővé teszi;;A 'protected', mert az csak leszármazottaknak engedi;;Az 'internal', mert az csak a szerelvényen belül érvényes;;A 'protected internal', amely a két módosító unióját képezi;;D;;Nyelvi eszközök EA
1;;5;;Mi a property-k (tulajdonságok) használatának elsődleges célja a publikus tagváltozókkal szemben?;;A kód méretének csökkentése;;Az objektum konzisztens állapotának biztosítása adatvalidációval;;A futásidejű teljesítmény növelése;;Az osztályok közötti öröklődés engedélyezése;;B;;Nyelvi eszközök 1
2;;6;;Mi történik, amikor egy property 'set' ága lefut?;;A property mögötti érték lekérdezése történik;;A 'value' kulcsszóval hivatkozott új érték beállítása történik;;Egy új objektumpéldány jön létre a memóriában;;A property láthatósága ideiglenesen megváltozik;;B;;Nyelvi eszközök 1
3;;4;;Melyik a helyes szintaxis egy csak olvasható (readonly) 'Age' property definiálására?;;public int Age { private get; };;public int Age { get; private set; };;public int Age { get; };;public int Age { set; };;C;;Nyelvi eszközök 1
4;;6;;Mi történik a háttérben egy auto-implementált property (pl. public string Name { get; set; }) létrehozásakor?;;A fordító egy publikus tagváltozót hoz létre;;Nem jön létre tagváltozó, az érték a veremben tárolódik;;A fordító generál egy rejtett, privát tagváltozót a property számára;;A property egy statikus változóhoz kötődik automatikusan;;C;;Nyelvi eszközök 1
5;;7;;Milyen módokon adható érték egy csak olvasható (readonly) auto-implementált tulajdonságnak (pl. public string Name { get; })?;;Bármelyik metódusból a 'set' kulcsszóval;;Kizárólag a konstruktorban vagy a deklaráció helyén, kezdőértékkel;;Kizárólag statikus metódusokból adható neki érték;;A 'get' ágon belülről, rekurzív módon;;B;;Nyelvi eszközök 1
6;;5;;Mit definiálunk a 'delegate' kulcsszó használatával C#-ban?;;Egy konkrét metódus implementációt;;Egy eseménykezelő láncot, ami automatikusan lefut;;Egy típust, ami egy adott szignatúrájú metódusra tud hivatkozni;;Egy absztrakt osztályt, aminek nincsenek tagváltozói;;C;;Nyelvi eszközök 1
7;;6;;Hogyan lehet egy delegate objektumhoz több metódusreferenciát is hozzáadni (multicast)?;;A 'new' kulcsszóval minden új metódusnál;;A metódusokat vesszővel elválasztva a konstruktorban;;A '+=' operátor használatával;;A 'Delegate.Add' statikus metódus hívásával;;C;;Nyelvi eszközök 1
8;;6;;Melyik a helyes módja egy delegate objektum által hivatkozott metódus meghívásának?;;A delegate objektumot úgy hívjuk, mintha egy függvény lenne;;A delegate '.Call()' metódusát kell használni;;A 'InvokeDelegate' kulcsszót kell használni;;A delegate-et nem lehet közvetlenül hívni, csak eseményen keresztül;;A;;Nyelvi eszközök 1
9;;5;;Milyen tervezési mintára épül a .NET eseménykezelési mechanizmusa?;;A Singleton (egykepéldányos) mintára;;A Factory (gyártó) mintára;;A Publisher/Subscriber (kiadó/feliratkozó) mintára;;A Decorator (dekorátor) mintára;;C;;Nyelvi eszközök 1
10;;4;;Mi a szerepe az 'event' kulcsszónak egy delegate típusú tagváltozó előtt?;;Jelzi, hogy a delegate csak egyetlen metódusra hivatkozhat;;Speciális védelmet ad a delegate-nek, eseménnyé alakítja;;Növeli a delegate teljesítményét a gyorsabb hívás érdekében;;Lehetővé teszi a delegate-nek, hogy értéket adjon vissza;;B;;Nyelvi eszközök 1
11;;7;;Miért fontos ellenőrizni egy eseményt (pl. Log) null értékre, mielőtt elsütjük?;;Mert ha nincs feliratkozó, az esemény null, és a hívása kivételt dob;;Hogy elkerüljük a végtelen ciklust a feliratkozók között;;Hogy a feliratkozók sorrendjét ellenőrizzük a hívás előtt;;Mert a null eseményhívás memóriaszivárgást okozhat;;A;;Nyelvi eszközök 1
12;;8;;Melyik állítás NEM igaz az 'event' és a 'delegate' közötti különbségre?;;Az event-et csak a tartalmazó osztályból lehet elsütni;;Az event-re nem lehet az '=' operátorral új hivatkozást adni;;Az event-re a '+=' és '-=' operátorokkal lehet fel- és leiratkozni;;Az event lehet lokális változó egy metóduson belül, a delegate nem;;D;;Nyelvi eszközök 1
13;;6;;Hogyan lehet leiratkozni egy eseményről C#-ban?;;A '-=' operátorral, megadva a korábban regisztrált kezelőfüggvényt;;Az '=' operátorral, null értéket adva az eseménynek;;A 'dispose' metódus meghívásával az eseményen;;A 'remove' kulcsszóval és az esemény nevével;;A;;Nyelvi eszközök 1
14;;5;;Mi az attribútumok (pl. [Serializable]) elsődleges funkciója a C# kódban?;;Futásidejű logikát adnak a kódelemekhez;;Deklaratív módon metaadatokat csatolnak a kódelemekhez;;Helyettesítik az öröklődést a kompozícióval;;Optimalizálják a fordító által generált IL kódot;;B;;Nyelvi eszközök 1
15;;7;;Melyik attribútummal jelezhetjük, hogy egy metódus elavult és használata nem javasolt?;;A [Deprecated] attribútummal;;A [NonSerialized] attribútummal;;Az [Obsolete] attribútummal;;A [Warning] attribútummal;;C;;Nyelvi eszközök 1
16;;4;;Az előadás alapján melyik az érték típus (value type)?;;string;;File;;struct;;interface;;C;;Nyelvi eszközök 1
17;;4;;Az előadás alapján melyik a referencia típus (reference type)?;;int;;bool;;class;;enum;;C;;Nyelvi eszközök 1
18;;6;;Mi a különbség egy `Person p1;` deklarációban, ha a Person egy 'struct' vagy egy 'class'?;;'struct' esetén null referencia, 'class' esetén létrejön az objektum;;Mindkét esetben létrejön az objektum alapértelmezett értékekkel;;Mindkét esetben csak egy null referencia jön létre a heap-en;;'struct' esetén létrejön az objektum, 'class' esetén csak egy null értékű referencia;;D;;Nyelvi eszközök 1
19;;5;;Hol foglal helyet egy lokális változóként deklarált 'struct' és 'class' példány?;;Mindkettő a heap-en (felügyelt memória);;A 'struct' a vermen (stack), a 'class' objektuma a heap-en;;Mindkettő a vermen (stack) a gyors elérés érdekében;;A 'class' a vermen (stack), a 'struct' a heap-en;;B;;Nyelvi eszközök 1
20;;6;;Mikor érdemes 'struct'-ot használni 'class' helyett az előadás szerint?;;Nagy, bonyolult adatszerkezetek modellezésére;;Amikor öröklődésre van szükségünk;;Kisméretű, adatszerű objektumok esetén a GC terhelésének csökkentésére;;Amikor az objektumainkat szálbiztosan kell kezelni;;C;;Nyelvi eszközök 1
21;;7;;Mit jelent a null-conditional operator (?.), pl. `Log?.Invoke(msg)` esetén?;;Ha a Log null, akkor kivételt dob;;Ha a Log null, akkor a program leáll;;Ha a Log nem null, akkor meghívja az Invoke metódust, különben nem csinál semmit;;Ha a Log nem null, akkor igaz logikai értékkel tér vissza;;C;;Nyelvi eszközök 1
22;;6;;Mi a különbség egy `Person[] persons = new Person[10];` tömblétrehozásnál, ha a Person `struct` vagy `class`?;;Semmi, a fordító mindkét esetben ugyanazt a kódot generálja;;struct esetén létrejön 10 objektum, class esetén csak 10 null referencia;;class esetén létrejön 10 objektum, struct esetén csak 10 üres referencia;;Mindkét esetben létrejön 10 objektum, de a class esetén a heap-en;;B;;Nyelvi eszközök 1
23;;7;;Milyen mechanizmussal lehet futásidőben lekérdezni egy osztály attribútumait?;;Szerializációval;;Delegátumokkal;;Reflection (reflexió) segítségével;;Pointer aritmetikával;;C;;Nyelvi eszközök 1
24;;5;;Hogyan lehet egy auto-implementált property-nek alapértelmezett értéket adni?;;A konstruktorban a 'default' kulcsszóval;;A deklaráció során az egyenlőségjel után megadva az értéket;;A get ágban egy if-else szerkezettel;;Nem lehet nekik alapértelmezett értéket adni;;B;;Nyelvi eszközök 1
25;;7;;Miért nem célszerű publikussá tenni egy osztály tagváltozóit az előadás szerint?;;Mert a publikus tagváltozók lassabbak, mint a property-k;;Mert nem garantálható az objektum konzisztens állapota;;Mert a publikus tagváltozókat a GC nem tudja felszabadítani;;Mert a publikus tagváltozók nem lehetnek statikusak;;B;;Nyelvi eszközök 1
26;;6;;Milyen néven érhető el a 'set' ágon belül az az érték, amit a property-nek be akarunk állítani?;;A 'data' nevű speciális változóban;;Az 'input' nevű beépített paraméterben;;A 'value' nevű implicit kulcsszóval;;A property nevével megegyező változóban;;C;;Nyelvi eszközök 1
27;;8;;Lehet-e egy property get és set ágának különböző a láthatósága?;;Nem, a property egészére csak egy láthatóság vonatkozhat;;Igen, de csak a get ág lehet szigorúbb (pl. private);;Igen, de csak a set ág lehet szigorúbb (pl. private);;Igen, bármelyik ág lehet szigorúbb vagy lazább is;;C;;Nyelvi eszközök 1
28;;6;;Melyik alternatív megoldás létezik a delegate-alapú összehasonlításra egy rendező algoritmusban?;;Az elemeknek implementálniuk kell az IComparable interfészt;;Az elemeknek implementálniuk kell a ISerializable interfészt;;Az elemeknek rendelkezniük kell egy 'SortKey' nevű property-vel;;Minden elemnek statikus 'Compare' metódussal kell rendelkeznie;;A;;Nyelvi eszközök 1
29;;5;;Milyen típusú metódusokra hivatkozhat egy delegate?;;Csak statikus metódusokra;;Csak nem statikus (példány) metódusokra;;Statikus és nem statikus metódusokra is;;Csak olyan metódusokra, amik ugyanabban az osztályban vannak;;C;;Nyelvi eszközök 1
30;;7;;Mi az alapja a .NET eseménykezelésének, ami a háttérben működik?;;Egy speciális, 'event' típusú objektum;;Egy multicast delegátból képzett speciális tagváltozó;;Egy láncolt lista, ami a feliratkozókat tárolja;;Egy beépített rendszerüzenet-sor (message queue);;B;;Nyelvi eszközök 1
31;;6;;Hogyan adhatunk át egy metódusreferenciát egy delegate-nek az egyszerűsített szintaktikával?;;A 'new' kulcsszóval és a metódus nevével;;Egyszerűen csak megadjuk a metódus nevét a delegate-nek értékül;;A metódus nevét stringként, idézőjelek között adjuk át;;Lambda kifejezéssel, ami meghívja a metódust;;B;;Nyelvi eszközök 1
32;;7;;A `[NonSerialized]` attribútum mit jelez a szerializációs folyamat számára?;;Hogy az egész osztályt nem szabad szerializálni;;Hogy az adott mezőt ki kell hagyni a szerializációból;;Hogy a mezőt titkosítva kell a stream-be írni;;Hogy a mező értéke null, és ezért nem érdemes elmenteni;;B;;Nyelvi eszközök 1
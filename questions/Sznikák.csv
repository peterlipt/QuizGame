1;4;Mi a futtatókörnyezet (runtime) egyik alapvető funkciója a diák alapján?;Hardvereszközök közvetlen kezelése;Egy absztrakt számítógép-architektúra (VM) biztosítása;Forráskód fordítása tetszőleges nyelvre;A felhasználói felület elemeinek megjelenítése;B;Futtatókörnyezetek
2;5;Milyen előnyt jelent a köztes nyelv (IL) használata a hordozhatóság szempontjából?;Minden platformra külön natív fordítót kell írni;Az n*m probléma helyett n+m fordítóra van szükség;A köztes nyelv közvetlenül fut a processzoron;A kód mérete minden esetben a felére csökken;B;Futtatókörnyezetek
3;6;Mikor történik a köztes kódról natív kódra fordítás a hatékonyság maximalizálása érdekében?;A forráskód írásával egy időben;A program telepítésekor a célgépen;A lehető legkésőbbi pillanatban, a végleges környezetben;Minden programindítás előtt, teljes egészében;C;Futtatókörnyezetek
4;5;Melyik NEM tartozik a futtatókörnyezetek által nyújtott biztonsági funkciók közé?;Automatikus szemétgyűjtés a memóriaszivárgás ellen;Futás közbeni hibák azonnali megfogása;Tetszőleges pointer-aritmetika engedélyezése;Adat- és kódellenőrzés a futtatás során;C;Futtatókörnyezetek
5;4;Milyen típusú kódot generál a Java fordító a forráskódból?;IL (Intermediate Language) kódot;Natív, processzor-specifikus kódot;Bytecode-ot, amit a JVM futtat;C++ forráskódot a maximális sebességért;C;Futtatókörnyezetek
6;4;Mi a Java "Write once, run/debug anywhere" elvének alapja?;A közös grafikus felület szabványa;A portolhatóság, melyet a JVM biztosít;Az ingyenesen elérhető fejlesztői eszközök;Az automatikus memória menedzsment;B;Futtatókörnyezetek
7;5;Melyik komponens NEM része a Java Virtuális Gép (JVM) belső felépítésének a bemutatott ábrán?;Classloader (osztálybetöltő);Verifier (kódellenőrző);Garbage Collector (szemétgyűjtő);Execution (végrehajtó motor);C;Futtatókörnyezetek
8;6;Melyik technológia biztosítja a Java-ban az automatikus memória menedzsmentet?;A "Nincs pointer!" elv szigorú betartása;A compile-time típusellenőrzés;A Garbage Collector (GC) működése;A beépített szálkezelési modell;C;Futtatókörnyezetek
9;4;Melyik két fő részből áll a .NET platform alapvető szerkezete?;Application és Operating System;Common Language Runtime (CLR) és Base Class Library (BCL);JIT fordító és NuGet csomagkezelő;Windows Forms és ASP.NET Core;B;Futtatókörnyezetek
10;5;Mi a Base Class Library (BCL) elsődleges szerepe a .NET ökoszisztémában?;A köztes kód (IL) futtatása és menedzselése;Alapvető osztálykönyvtárak biztosítása (pl. string, file);Külső, harmadik féltől származó csomagok kezelése;A kód natívvá fordítása futás közben;B;Futtatókörnyezetek
11;5;Melyik .NET technológia szolgál webes frontend alkalmazások készítésére az előadás szerint?;Entity Framework Core;Windows Presentation Foundation (WPF);ASP.NET Core vagy Blazor;ADO.NET adatkezelő;C;Futtatókörnyezetek
12;6;Mi a legfőbb különbség a régi .NET Framework és a modern .NET (.NET 5+) között?;A .NET Framework támogatja a C# nyelvet, a .NET nem;A .NET Framework cross-platform, a modern .NET csak Windows;A .NET Framework Windows-specifikus, a modern .NET cross-platform;A modern .NET nem tartalmaz szemétgyűjtőt;C;Futtatókörnyezetek
13;7;Mi a .NET Standard pontos funkciója?;Egy konkrét, futtatható .NET implementáció;Egy szabvány, ami a forráskód-hordozhatóságot segíti;A .NET Framework és a .NET Core egy közös verziója;Egy eszköz a Unity játékfejlesztéshez;B;Futtatókörnyezetek
14;5;Melyik a CLR (Common Language Runtime) egyik legfontosabb tervezési szempontja?;Kizárólag egy programnyelv (C#) támogatása;A korábbi technológiáktól való teljes elzárkózás;Több programnyelv támogatása és integrációja;A manuális memóriakezelés megkövetelése;C;Futtatókörnyezetek
15;6;Mi a Common Type System (CTS) szerepe a .NET-ben?;A nyelvek közötti típuskompatibilitás biztosítása;A közös szintaktikai szabályok definiálása;A szemétgyűjtő algoritmusának meghatározása;A kivételkezelés egységesítése;A;Futtatókörnyezetek
16;6;Melyik NEM a CLR komponense a bemutatott ábra alapján?;Szálkezelő (Thread Manager);IL -> Natív JIT-fordító;Roslyn fordító platform;COM Marshaler;C;Futtatókörnyezetek
17;5;Mit jelent az, hogy a .NET nyelvfüggetlen?;Minden .NET nyelvet ugyanaz a fordító fordít;A keretrendszer szolgáltatásai minden nyelv számára elérhetőek;Kizárólag a C# nyelvvel lehet elérni a CLR funkcióit;A különböző nyelveken írt kódok nem keverhetőek;B;Futtatókörnyezetek
18;7;Melyik az egyetlen nyelv a diák szerint, ahol a natív és felügyelt kód keveredhet?;A C#, a .NET fő programozási nyelve;A Visual Basic .NET (VB.NET);A felügyelt C++ (managed C++);Az F#, a funkcionális programnyelv;C;Futtatókörnyezetek
19;4;Mire cseréli le a C# a C++-ban megszokott mutatókat (pointereket)?;Kizárólag érték szerinti típusátadásra;Referenciákra, a biztonságosabb memóriakezelésért;Speciális, "unsafe" kontextusra mindenhol;Globális változók használatára;B;Futtatókörnyezetek
20;6;Mi a felügyelt adatok (managed data) legfőbb jellemzője a .NET-ben?;Minden objektumot manuálisan kell felszabadítani;Nincs automatikus élettartam-felügyelet;Minden .NET objektumot a GC (Garbage Collector) takarít el;A 'delete' utasítás használata kötelező;C;Futtatókörnyezetek
21;7;Hogyan működik a .NET szemétgyűjtőjének "mark & compact" fázisa?;Megjelöli és azonnal törli az objektumokat, megszámolja a referenciákat;Megjelöli az élő objektumokat, majd a memóriát tömöríti;Csak megjelöli a felesleges objektumokat, de nem törli őket;Tömöríti a memóriát, majd ellenőrzi a hivatkozásokat;B;Futtatókörnyezetek
22;6;Mi a Large Object Heap (LOH) egyik hátránya vagy speciális jellemzője?;A rajta lévő objektumokat a GC nem tömöríti;Kizárólag kis méretű objektumok tárolására szolgál;Determinisztikus és rendkívül gyors a takarítása;Minden programindításkor teljesen kiürül;A;Futtatókörnyezetek
23;4;Mi a felügyelt kód (managed code) egyik legfontosabb tulajdonsága?;Lehetővé teszi a tetszőleges, nem biztonságos típuskonverziót;Nem ellenőrzi a tömbök indexhatárait;Szigorú típusellenőrzésnek vethető alá;Nem képes kezelni a futásidejű kivételeket;C;Futtatókörnyezetek
24;5;Milyen lépésekből áll a .NET fordítási és végrehajtási folyamata?;Forráskód -> Natív kód -> Végrehajtás;Forráskód -> IL -> Interpretálás;Forráskód -> Nyelvi fordító (IL) -> JIT fordító (Natív);Forráskód -> JIT fordító -> Végrehajtás;C;Futtatókörnyezetek
25;5;Mit tartalmaz egy .NET szerelvény (assembly) a köztes kód (IL) mellett?;A teljes forráskódot .cs vagy .vb formában;Az operációs rendszerre vonatkozó drivereket;Metaadatokat a szerelvényről és a benne lévő típusokról;Egy előre lefordított natív másolatot minden platformra;C;Futtatókörnyezetek
26;6;Mikor történik meg a JIT (Just-In-Time) fordítás egy adott metódusra?;A program legelső indításakor az összes metódusra;A szerelvény (assembly) buildelése során;A metódus legelső meghívásakor a futás során;Minden egyes alkalommal, amikor a metódust meghívják;C;Futtatókörnyezetek
27;4;Mi a .NET szerelvény (assembly) elsődleges szerepe?;A forráskód logikai csoportosítása névterekbe;A telepítés, verziókezelés és újrafelhasználás egysége;Egy ideiglenes fájl a fordítási folyamat során;Egy konfigurációs fájl a futtatókörnyezet számára;B;Futtatókörnyezetek
28;6;Mi a szerelvény-referenciák egyik legfontosabb szabálya a körkörös függőségek elkerülésére?;A referencia mindig kétirányú kell, hogy legyen;Egy .exe fájl nem hivatkozhat .dll fájlra;A referenciának egyirányúnak kell lennie (függőségi fa);Bármelyik szerelvény hivatkozhat bármelyik másikra;C;Futtatókörnyezetek
29;5;Mire szolgál a NuGet a .NET ökoszisztémában?;A .NET keretrendszer belső komponenseinek kezelésére;A forráskód verziókövetésére (mint a Git);Egy csomagkezelő, külső könyvtárak beillesztésére;A C# kód IL kódra való fordítására;C;Futtatókörnyezetek
30;6;A szemantikus verziózás (Semantic Versioning) szerint mit jelez a MAJOR szám változása (pl. 2.1 -> 3.0)?;Kompatibilitástörő változást, ami a régi kódot elronthatja;Egy új, de visszafelé kompatibilis funkció hozzáadását;Egy kisebb hibajavítást vagy szervizcsomagot;A build sorszámának egyszerű növekedését;A;Futtatókörnyezetek
31;6;Milyen telepítési modellt részesít előnyben a modern .NET (.NET Core és .NET 5+)?;"Shared" (megosztott), ahol a DLL-ek egy központi GAC mappában vannak;"Private" (privát), ahol a DLL-ek az alkalmazás mappájában vannak;Online telepítést, ahol a DLL-ek futás közben töltődnek le;"Hybrid" (hibrid), ahol a DLL-ek fele privát, fele megosztott;B;Futtatókörnyezetek
32;7;Mi a klasszikus "DLL Hell" probléma lényege?;Amikor egy DLL fájl túl naggyá válik a betöltéshez;Amikor egy központi mappában lévő DLL-t felülír egy inkompatibilis verzió;Amikor a fejlesztő elfelejt hivatkozni egy szükséges DLL-re;Amikor egy DLL fájl vírusos fertőzést kap;B;Futtatókörnyezetek
33;5;Egy Visual Studio solution-ben hogyan a legcélszerűbb megoldani, hogy egy "App.exe" projekt használja egy "Library.dll" projekt kódját?;Az "App.exe" projektben szerelvény referenciát adunk a "Library.dll" fájlra;Mindkét projektet egy közös NuGet csomagba tesszük;Az "App.exe" projektben projekt referenciát adunk a "Library.dll" projekthez;A "Library.dll" forráskódját átmásoljuk az "App.exe" projektbe;C;Futtatókörnyezetek
34;5;Melyik réteg található közvetlenül az alkalmazás (Application) és az operációs rendszer (Operating System) között a bemutatott architektúrában?;A hardver absztrakciós réteg;A felhasználói felület (UI) rétege;A futtatókörnyezet (Runtime);A hálózati kommunikációs réteg;C;Futtatókörnyezetek
35;7;Mi a fő oka annak, hogy a felügyelt C++-t "Total Control"-nak is nevezik a diák kontextusában?;Mert ez az egyetlen nyelv, ami a leggyorsabban fut;Mert ez az egyetlen nyelv, ahol a natív és felügyelt kód/adat keveredhet;Mert a Microsoft ezt a nyelvet fejleszti a legaktívabban;Mert teljes kontrollt ad a felhasználói felület felett;B;Futtatókörnyezetek
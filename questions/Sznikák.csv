1;;4;;Mi a futtatókörnyezet (runtime) egyik alapvető funkciója a diák alapján?;;Hardvereszközök közvetlen kezelése;;Egy absztrakt számítógép-architektúra (VM) biztosítása;;Forráskód fordítása tetszőleges nyelvre;;A felhasználói felület elemeinek megjelenítése;;B;;Futtatókörnyezetek
2;;5;;Milyen előnyt jelent a köztes nyelv (IL) használata a hordozhatóság szempontjából?;;Minden platformra külön natív fordítót kell írni;;Az n*m probléma helyett n+m fordítóra van szükség;;A köztes nyelv közvetlenül fut a processzoron;;A kód mérete minden esetben a felére csökken;;B;;Futtatókörnyezetek
3;;6;;Mikor történik a köztes kódról natív kódra fordítás a hatékonyság maximalizálása érdekében?;;A forráskód írásával egy időben;;A program telepítésekor a célgépen;;A lehető legkésőbbi pillanatban, a végleges környezetben;;Minden programindítás előtt, teljes egészében;;C;;Futtatókörnyezetek
4;;5;;Melyik NEM tartozik a futtatókörnyezetek által nyújtott biztonsági funkciók közé?;;Automatikus szemétgyűjtés a memóriaszivárgás ellen;;Futás közbeni hibák azonnali megfogása;;Tetszőleges pointer-aritmetika engedélyezése;;Adat- és kódellenőrzés a futtatás során;;C;;Futtatókörnyezetek
5;;4;;Milyen típusú kódot generál a Java fordító a forráskódból?;;IL (Intermediate Language) kódot;;Natív, processzor-specifikus kódot;;Bytecode-ot, amit a JVM futtat;;C++ forráskódot a maximális sebességért;;C;;Futtatókörnyezetek
6;;4;;"Mi a Java ""Write once, run/debug anywhere"" elvének alapja?";;A közös grafikus felület szabványa;;A portolhatóság, melyet a JVM biztosít;;Az ingyenesen elérhető fejlesztői eszközök;;Az automatikus memória menedzsment;;B;;Futtatókörnyezetek
7;;5;;Melyik komponens NEM része a Java Virtuális Gép (JVM) belső felépítésének a bemutatott ábrán?;;Classloader (osztálybetöltő);;Verifier (kódellenőrző);;Garbage Collector (szemétgyűjtő);;Execution (végrehajtó motor);;C;;Futtatókörnyezetek
8;;6;;Melyik technológia biztosítja a Java-ban az automatikus memória menedzsmentet?;;"A ""Nincs pointer!"" elv szigorú betartása";;A compile-time típusellenőrzés;;A Garbage Collector (GC) működése;;A beépített szálkezelési modell;;C;;Futtatókörnyezetek
9;;4;;Melyik két fő részből áll a .NET platform alapvető szerkezete?;;Application és Operating System;;Common Language Runtime (CLR) és Base Class Library (BCL);;JIT fordító és NuGet csomagkezelő;;Windows Forms és ASP.NET Core;;B;;Futtatókörnyezetek
10;;5;;Mi a Base Class Library (BCL) elsődleges szerepe a .NET ökoszisztémában?;;A köztes kód (IL) futtatása és menedzselése;;Alapvető osztálykönyvtárak biztosítása (pl. string, file);;Külső, harmadik féltől származó csomagok kezelése;;A kód natívvá fordítása futás közben;;B;;Futtatókörnyezetek
11;;5;;Melyik .NET technológia szolgál webes frontend alkalmazások készítésére az előadás szerint?;;Entity Framework Core;;Windows Presentation Foundation (WPF);;ASP.NET Core vagy Blazor;;ADO.NET adatkezelő;;C;;Futtatókörnyezetek
12;;6;;Mi a legfőbb különbség a régi .NET Framework és a modern .NET (.NET 5+) között?;;A .NET Framework támogatja a C# nyelvet, a .NET nem;;A .NET Framework cross-platform, a modern .NET csak Windows;;A .NET Framework Windows-specifikus, a modern .NET cross-platform;;A modern .NET nem tartalmaz szemétgyűjtőt;;C;;Futtatókörnyezetek
13;;7;;Mi a .NET Standard pontos funkciója?;;Egy konkrét, futtatható .NET implementáció;;Egy szabvány, ami a forráskód-hordozhatóságot segíti;;A .NET Framework és a .NET Core egy közös verziója;;Egy eszköz a Unity játékfejlesztéshez;;B;;Futtatókörnyezetek
14;;5;;Melyik a CLR (Common Language Runtime) egyik legfontosabb tervezési szempontja?;;Kizárólag egy programnyelv (C#) támogatása;;A korábbi technológiáktól való teljes elzárkózás;;Több programnyelv támogatása és integrációja;;A manuális memóriakezelés megkövetelése;;C;;Futtatókörnyezetek
15;;6;;Mi a Common Type System (CTS) szerepe a .NET-ben?;;A nyelvek közötti típuskompatibilitás biztosítása;;A közös szintaktikai szabályok definiálása;;A szemétgyűjtő algoritmusának meghatározása;;A kivételkezelés egységesítése;;A;;Futtatókörnyezetek
16;;6;;Melyik NEM a CLR komponense a bemutatott ábra alapján?;;Szálkezelő (Thread Manager);;IL -> Natív JIT-fordító;;Roslyn fordító platform;;COM Marshaler;;C;;Futtatókörnyezetek
17;;5;;Mit jelent az, hogy a .NET nyelvfüggetlen?;;Minden .NET nyelvet ugyanaz a fordító fordít;;A keretrendszer szolgáltatásai minden nyelv számára elérhetőek;;Kizárólag a C# nyelvvel lehet elérni a CLR funkcióit;;A különböző nyelveken írt kódok nem keverhetőek;;B;;Futtatókörnyezetek
18;;7;;Melyik az egyetlen nyelv a diák szerint, ahol a natív és felügyelt kód keveredhet?;;A C#, a .NET fő programozási nyelve;;A Visual Basic .NET (VB.NET);;A felügyelt C++ (managed C++);;Az F#, a funkcionális programnyelv;;C;;Futtatókörnyezetek
19;;4;;Mire cseréli le a C# a C++-ban megszokott mutatókat (pointereket)?;;Kizárólag érték szerinti típusátadásra;;Referenciákra, a biztonságosabb memóriakezelésért;;"Speciális, ""unsafe"" kontextusra mindenhol";;Globális változók használatára;;B;;Futtatókörnyezetek
20;;6;;Mi a felügyelt adatok (managed data) legfőbb jellemzője a .NET-ben?;;Minden objektumot manuálisan kell felszabadítani;;Nincs automatikus élettartam-felügyelet;;Minden .NET objektumot a GC (Garbage Collector) takarít el;;A 'delete' utasítás használata kötelező;;C;;Futtatókörnyezetek
21;;7;;"Hogyan működik a .NET szemétgyűjtőjének ""mark & compact"" fázisa?";;Megjelöli és azonnal törli az objektumokat, megszámolja a referenciákat;;Megjelöli az élő objektumokat, majd a memóriát tömöríti;;Csak megjelöli a felesleges objektumokat, de nem törli őket;;Tömöríti a memóriát, majd ellenőrzi a hivatkozásokat;;B;;Futtatókörnyezetek
22;;6;;Mi a Large Object Heap (LOH) egyik hátránya vagy speciális jellemzője?;;A rajta lévő objektumokat a GC nem tömöríti;;Kizárólag kis méretű objektumok tárolására szolgál;;Determinisztikus és rendkívül gyors a takarítása;;Minden programindításkor teljesen kiürül;;A;;Futtatókörnyezetek
23;;4;;Mi a felügyelt kód (managed code) egyik legfontosabb tulajdonsága?;;Lehetővé teszi a tetszőleges, nem biztonságos típuskonverziót;;Nem ellenőrzi a tömbök indexhatárait;;Szigorú típusellenőrzésnek vethető alá;;Nem képes kezelni a futásidejű kivételeket;;C;;Futtatókörnyezetek
24;;5;;Milyen lépésekből áll a .NET fordítási és végrehajtási folyamata?;;Forráskód -> Natív kód -> Végrehajtás;;Forráskód -> IL -> Interpretálás;;Forráskód -> Nyelvi fordító (IL) -> JIT fordító (Natív);;Forráskód -> JIT fordító -> Végrehajtás;;C;;Futtatókörnyezetek
25;;5;;Mit tartalmaz egy .NET szerelvény (assembly) a köztes kód (IL) mellett?;;A teljes forráskódot .cs vagy .vb formában;;Az operációs rendszerre vonatkozó drivereket;;Metaadatokat a szerelvényről és a benne lévő típusokról;;Egy előre lefordított natív másolatot minden platformra;;C;;Futtatókörnyezetek
26;;6;;Mikor történik meg a JIT (Just-In-Time) fordítás egy adott metódusra?;;A program legelső indításakor az összes metódusra;;A szerelvény (assembly) buildelése során;;A metódus legelső meghívásakor a futás során;;Minden egyes alkalommal, amikor a metódust meghívják;;C;;Futtatókörnyezetek
27;;4;;Mi a .NET szerelvény (assembly) elsődleges szerepe?;;A forráskód logikai csoportosítása névterekbe;;A telepítés, verziókezelés és újrafelhasználás egysége;;Egy ideiglenes fájl a fordítási folyamat során;;Egy konfigurációs fájl a futtatókörnyezet számára;;B;;Futtatókörnyezetek
28;;6;;Mi a szerelvény-referenciák egyik legfontosabb szabálya a körkörös függőségek elkerülésére?;;A referencia mindig kétirányú kell, hogy legyen;;Egy .exe fájl nem hivatkozhat .dll fájlra;;A referenciának egyirányúnak kell lennie (függőségi fa);;Bármelyik szerelvény hivatkozhat bármelyik másikra;;C;;Futtatókörnyezetek
29;;5;;Mire szolgál a NuGet a .NET ökoszisztémában?;;A .NET keretrendszer belső komponenseinek kezelésére;;A forráskód verziókövetésére (mint a Git);;Egy csomagkezelő, külső könyvtárak beillesztésére;;A C# kód IL kódra való fordítására;;C;;Futtatókörnyezetek
30;;6;;A szemantikus verziózás (Semantic Versioning) szerint mit jelez a MAJOR szám változása (pl. 2.1 -> 3.0)?;;Kompatibilitástörő változást, ami a régi kódot elronthatja;;Egy új, de visszafelé kompatibilis funkció hozzáadását;;Egy kisebb hibajavítást vagy szervizcsomagot;;A build sorszámának egyszerű növekedését;;A;;Futtatókörnyezetek
31;;6;;Milyen telepítési modellt részesít előnyben a modern .NET (.NET Core és .NET 5+)?;;"""Shared"" (megosztott), ahol a DLL-ek egy központi GAC mappában vannak";;"""Private"" (privát), ahol a DLL-ek az alkalmazás mappájában vannak";;Online telepítést, ahol a DLL-ek futás közben töltődnek le;;"""Hybrid"" (hibrid), ahol a DLL-ek fele privát, fele megosztott";;B;;Futtatókörnyezetek
32;;7;;"Mi a klasszikus ""DLL Hell"" probléma lényege?";;Amikor egy DLL fájl túl naggyá válik a betöltéshez;;Amikor egy központi mappában lévő DLL-t felülír egy inkompatibilis verzió;;Amikor a fejlesztő elfelejt hivatkozni egy szükséges DLL-re;;Amikor egy DLL fájl vírusos fertőzést kap;;B;;Futtatókörnyezetek
33;;5;;"Egy Visual Studio solution-ben hogyan a legcélszerűbb megoldani, hogy egy ""App.exe"" projekt használja egy ""Library.dll"" projekt kódját?";;"Az ""App.exe"" projektben szerelvény referenciát adunk a ""Library.dll"" fájlra";;Mindkét projektet egy közös NuGet csomagba tesszük;;"Az ""App.exe"" projektben projekt referenciát adunk a ""Library.dll"" projekthez";;"A ""Library.dll"" forráskódját átmásoljuk az ""App.exe"" projektbe";;C;;Futtatókörnyezetek
34;;5;;Melyik réteg található közvetlenül az alkalmazás (Application) és az operációs rendszer (Operating System) között a bemutatott architektúrában?;;A hardver absztrakciós réteg;;A felhasználói felület (UI) rétege;;A futtatókörnyezet (Runtime);;A hálózati kommunikációs réteg;;C;;Futtatókörnyezetek
35;;7;;"Mi a fő oka annak, hogy a felügyelt C++-t ""Total Control""-nak is nevezik a diák kontextusában?";;Mert ez az egyetlen nyelv, ami a leggyorsabban fut;;Mert ez az egyetlen nyelv, ahol a natív és felügyelt kód/adat keveredhet;;Mert a Microsoft ezt a nyelvet fejleszti a legaktívabban;;Mert teljes kontrollt ad a felhasználói felület felett;;B;;Futtatókörnyezetek
1;;5;;Mi a viszony az 'int' és a 'System.Int32' között C#-ban?;;Az 'int' egy érték típus, míg a 'System.Int32' egy referencia típus;;Az 'int' a C# nyelv aliasa a .NET-es System.Int32 típusra;;Az 'int' egy ősosztálya a System.Int32-nek, több funkcionalitással;;A System.Int32 használata lassabb, mert az egy teljes értékű objektum;;B;;Nyelvi eszközök EA
2;;6;;Melyik állítás igaz a System.Object típusra C#-ban?;;Csak a referencia típusok származnak a System.Object-ből implicit módon;;Még az elemi típusok, mint az int vagy double is, implicit módon belőle származnak;;A System.Object egy interfész, amit minden osztálynak implementálnia kell;;A felhasználónak expliciten kell örököltetnie minden osztályt a System.Object-ből;;B;;Nyelvi eszközök EA
3;;4;;Hol jönnek létre az érték típusok (pl. struct) és a referencia típusok (pl. class) példányai?;;Mindkét típusú objektum a heap-en jön létre a 'new' kulcsszóval;;Az érték típusok a heap-en, a referencia típusok a vermen (stack) jönnek létre;;Az érték típusok a vermen (stack), a referencia típusok a heap-en jönnek létre;;Mindkét típusú objektum a vermen (stack) jön létre a gyors elérés érdekében;;C;;Nyelvi eszközök EA
4;;6;;Mi az érték típusok (value types) használatának egyik legjelentősebb előnye?;;Nem kell a Garbage Collectornak (GC) takarítania őket, ami teljesítménynövekedést okoz;;Bonyolult objektumhierarchiák és öröklési láncok hozhatók létre velük;;Mindig referenciaként adódnak át, így nem kell őket másolni;;Automatikusan rendelkeznek szinkronizációs mechanizmusokkal;;A;;Nyelvi eszközök EA
5;;6;;Melyik korlátozás vonatkozik a 'struct'-okra a C# nyelvben?;;Nem implementálhatnak interfészeket, ellentétben az osztályokkal;;Nem lehetnek tagfüggvényeik, csak adattagjaik lehetnek;;Nem lehet belőlük örökölni, és ők sem örökölhetnek más osztályoktól;;Nem használhatók generikus kollekciókban a másolódásuk miatt;;C;;Nyelvi eszközök EA
6;;7;;Miben különbözik a C# 'struct' kulcsszava a C++ 'struct' kulcsszavától az alapértelmezett láthatóság terén?;;A C# struct tagjai alapértelmezetten public, míg a C++-ban private;;A C#-ban nincs különbség, mindkettőben alapértelmezetten public;;A C# struct tagjai alapértelmezetten private, mint a C# class-oké;;A C# struct nem egy class, ellentétben a C++ struct-tal;;D;;Nyelvi eszközök EA
7;;5;;Mi történik, amikor egy 'string' típusú változó tartalmát módosítjuk C#-ban?;;A művelet egy új string példányt hoz létre a memóriában az új tartalommal;;A meglévő string objektum tartalma módosul a memóriában (in-place);;A fordító hibát jelez, mivel a stringek konstansok és nem módosíthatók;;A string automatikusan egy StringBuilder objektummá konvertálódik;;A;;Nyelvi eszközök EA
8;;6;;Miért nem javasolt a '+' operátor használata stringek összefűzésére egy cikluson belül?;;Mert a '+' operátor ciklusban való használata fordítási hibát okoz;;Mert minden egyes összefűzés új, ideiglenes string objektumot hoz létre;;Mert a stringek maximális hossza korlátozott, és a ciklus túllépheti azt;;Mert a veremtúlcsordulás (stack overflow) veszélye fennáll;;B;;Nyelvi eszközök EA
9;;4;;Melyik a két leghatékonyabb, javasolt módszer stringek dinamikus összeállítására?;;A '+' operátor és a String.Join metódus használata;;A String.Concat metódus és a karaktertömbök kezelése;;"A StringBuilder osztály és a string interpoláció ($""..."") használata";;A String.Format metódus és a reguláris kifejezések alkalmazása;;C;;Nyelvi eszközök EA
10;;4;;Mi az 'enum' (felsorolt típus) elsődleges célja a C# nyelvben?;;Számok helyett nevesített elemek használata a jobb olvashatóságért;;Nagy teljesítményű matematikai számítások elvégzése;;Komplex adatszerkezetek, például láncolt listák létrehozása;;Dinamikus típuskezelés és futásidejű típusellenőrzés;;A;;Nyelvi eszközök EA
11;;7;;Mire szolgál a '[Flags]' attribútum egy 'enum' típus definíciója előtt?;;Azt jelzi, hogy az enum értékei nem kombinálhatók egymással;;Lehetővé teszi, hogy az enum értékeit bitműveletekkel lehessen kombinálni;;Megakadályozza az enum elemeinek szöveggé alakítását a ToString() metódussal;;Azt jelöli, hogy az enum csak lebegőpontos számokat tartalmazhat;;B;;Nyelvi eszközök EA
12;;5;;Melyik NEM egy C# osztály lehetséges tagja az előadás alapján?;;Field (mező), amely egy tagváltozót reprezentál;;Property (tulajdonság), amely get/set metódusokkal éri el az értéket;;Namespace (névtér), amely logikailag csoportosítja az osztályt;;Method (metódus), amely a funkcionalitást implementálja;;C;;Nyelvi eszközök EA
13;;6;;Mire használható egy indexer egy C# osztályban?;;Az osztály egyetlen numerikus értékének beállítására;;A konténer típusú osztály elemeinek indexelt elérésére a [ ] jellel;;Az osztály fizikai memóriacímének lekérdezésére;;Statikus metódusok dinamikus meghívására név alapján;;B;;Nyelvi eszközök EA
14;;7;;Hogyan működik a rövidzár kiértékelés (short-circuit evaluation) a '&&' operátornál?;;Mindkét operandust kiértékeli, függetlenül az első értékétől;;Ha az első operandus 'false', a másodikat már nem értékeli ki;;Ha az első operandus 'true', a másodikat már nem értékeli ki;;Kizárólag egész számok közötti logikai ÉS műveletre használható;;B;;Nyelvi eszközök EA
15;;6;;Melyik operátor NEM definiálható felül C#-ban?;;A '+' aritmetikai operátor két egyedi osztály összeadására;;A '==' relációs operátor két objektum egyenlőségének vizsgálatára;;A '()' függvényhívás operátor az osztály funktorrá tételéhez;;A '=' hozzárendelés operátor;;D;;Nyelvi eszközök EA
16;;4;;Milyen deklarációs szintaxissal hozunk létre egy kétdimenziós (nem beágyazott) tömböt?;;int[] TwoDim egy dimenziós tömb;;int[,] TwoDim kétdimenziós tömb;;int[][] TwoDim tömbök tömbje;;int[2D] TwoDim speciális szintaxis;;B;;Nyelvi eszközök EA
17;;7;;Mi a különbség egy érték típusú és egy referencia típusú elemeket tartalmazó tömb létrehozása között?;;Semmi, a fordító mindkét esetben ugyanazt a kódot generálja;;Érték típusnál csak a hely jön létre, referencia típusnál a hely és az objektumok is;;Érték típusnál a hely és az elemek is létrejönnek, referencia típusnál csak a referenciák helye;;Referencia típusú tömböt nem lehet létrehozni, csak listát;;C;;Nyelvi eszközök EA
18;;5;;Melyik láthatósági módosító teszi lehetővé az elérést csak az adott szerelvényen (assembly) belül?;;A 'public', amely mindenki számára láthatóvá teszi;;A 'private', amely csak az osztályon belüli elérést engedi;;Az 'internal', amely szerelvényen belüli publikus elérést biztosít;;A 'protected', amely a leszármazottak számára teszi elérhetővé;;C;;Nyelvi eszközök EA
19;;6;;Melyik kulcsszót kell használni egy ősosztálybeli virtuális függvény felülírásához egy leszármazottban?;;A 'virtual' kulcsszót a leszármazottban is;;Az 'override' kulcsszót, jelezve a felülírás szándékát;;A 'new' kulcsszót a metódus elrejtésére;;Az 'abstract' kulcsszót a konkrét implementációhoz;;B;;Nyelvi eszközök EA
20;;6;;Mi a különbség az 'as' és a hagyományos (zárójeles) cast között?;;Az 'as' operátor gyorsabb, de csak referencia típusokra működik;;Az 'as' kivételt dob sikertelen konverziónál, a cast 'null'-t ad;;A cast kivételt dob sikertelen konverziónál, az 'as' 'null'-t ad vissza;;Nincs különbség, az 'as' csak egy szintaktikai könnyítés;;C;;Nyelvi eszközök EA
21;;6;;Milyen esetben használjuk a 'const' és milyenben a 'readonly' kulcsszót?;;A 'const' futásidejű, a 'readonly' fordításidejű konstans;;A 'const' csak osztályszintű, a 'readonly' lehet példányszintű is;;A 'const' csak referencia típusokra, a 'readonly' csak érték típusokra jó;;A 'const' fordításidejű, míg a 'readonly' értéke futásidőben is meghatározható;;D;;Nyelvi eszközök EA
22;;7;;Mikor hívódik meg egy osztály statikus konstruktora?;;Minden egyes példány létrehozásakor a normál konstruktor előtt;;Az első példány létrehozása vagy az első statikus tag elérése előtt;;A program leállásakor a statikus adatok felszabadítására;;A fejlesztőnek kell manuálisan meghívnia a program elején;;B;;Nyelvi eszközök EA
23;;5;;Mi a 'ref' kulcsszó szerepe egy függvény paraméterlistájában?;;Azt jelzi, hogy a paraméter egy referencia típusú objektum;;Lehetővé teszi, hogy a függvény az eredeti változó értékét módosítsa;;Azt jelöli, hogy a paramétert a függvény nem módosíthatja;;A paraméter opcionálissá tételére szolgál;;B;;Nyelvi eszközök EA
24;;6;;Mi a fő különbség a 'ref' és az 'out' paraméterek között?;;A 'ref' befelé és kifelé, az 'out' csak kifelé szállít adatot;;Az 'out' befelé és kifelé, a 'ref' csak befelé szállít adatot;;A 'ref' változónak nem kell értéket adni hívás előtt, az 'out'-nak igen;;A hívás helyén csak a 'ref' kulcsszót kell kitenni, az 'out'-ot nem;;A;;Nyelvi eszközök EA
25;;7;;"Mi történik a ""boxing"" folyamat során C#-ban?";;Egy referencia típusú objektumot alakít át érték típussá a gyorsabb kezelésért;;Egy érték típust csomagol egy objektumba a heap-en, és bemásolja az értékét;;Egy objektum adatait egy bináris fájlba (dobozba) szerializálja;;Egy függvényhívást csomagol egy delegate objektumba;;B;;Nyelvi eszközök EA
26;;4;;Melyik kulcsszóval kezdődik az a blokk, ami a hibakezelés során mindig lefut, akár volt hiba, akár nem?;;A 'try' blokk, amely a védett kódot tartalmazza;;A 'catch' blokk, amely a kivételeket kapja el;;A 'throw' kulcsszó, amely kivételt dob;;A 'finally' blokk, amely a garantáltan lefutó kódot tartalmazza;;D;;Nyelvi eszközök EA
27;;4;;Mire szolgál a 'namespace' (névtér) a C# kódban?;;A kód fizikai elrendezésére a merevlemezen;;Osztályok és típusok logikai csoportosítására, a névütközések elkerülésére;;A memóriakezelés és a szemétgyűjtés finomhangolására;;Egy adott fájlban lévő kód fordítási egységének definiálására;;B;;Nyelvi eszközök EA
28;;6;;Melyik interfészt kell egy kollekciónak implementálnia, hogy használható legyen a 'foreach' ciklussal?;;Az ICollection interfészt a darabszám lekérdezéséhez;;Az IEnumerable interfészt, amely egy GetEnumerator metódust ír elő;;Az IEnumerator interfészt, amely a MoveNext és Current tagokat tartalmazza;;Az IDisposable interfészt a ciklus végi erőforrás-felszabadításhoz;;B;;Nyelvi eszközök EA
29;;5;;Melyik NEM a System.Object osztály virtuális metódusa az előadás alapján?;;ToString(), a szöveges reprezentációért;;GetHashCode(), a hash kód generálásáért;;Equals(object o), az azonosság vizsgálatáért;;GetType(), a futásidejű típusinformációért;;D;;Nyelvi eszközök EA
30;;5;;Melyik típus alkalmas nagy pontosságú pénzügyi számításokra, elkerülve a lebegőpontos hibákat?;;A 'float' típus, amely 32 bites lebegőpontos szám;;A 'double' típus, amely 64 bites lebegőpontos szám;;A 'decimal' típus, amely 128 bites, fixpontos számábrázolású;;A 'long' típus, amely 64 bites egész szám;;C;;Nyelvi eszközök EA
31;;8;;Melyik láthatósági módosító kombináció teszi elérhetővé egy tagot a tartalmazó szerelvényen belül BÁRHOL, illetve azon kívül CSAK a leszármazottakban?;;A 'public', mert az mindenhol elérhetővé teszi;;A 'protected', mert az csak leszármazottaknak engedi;;Az 'internal', mert az csak a szerelvényen belül érvényes;;A 'protected internal', amely a két módosító unióját képezi;;D;;Nyelvi eszközök EA
1;;5;;Mi a property-k (tulajdonságok) használatának elsődleges célja a publikus tagváltozókkal szemben?;;A kód méretének csökkentése;;Az objektum konzisztens állapotának biztosítása adatvalidációval;;A futásidejű teljesítmény növelése;;Az osztályok közötti öröklődés engedélyezése;;B;;Nyelvi eszközök 1
2;;6;;Mi történik, amikor egy property 'set' ága lefut?;;A property mögötti érték lekérdezése történik;;A 'value' kulcsszóval hivatkozott új érték beállítása történik;;Egy új objektumpéldány jön létre a memóriában;;A property láthatósága ideiglenesen megváltozik;;B;;Nyelvi eszközök 1
3;;4;;Melyik a helyes szintaxis egy csak olvasható (readonly) 'Age' property definiálására?;;public int Age { private get; };;public int Age { get; private set; };;public int Age { get; };;public int Age { set; };;C;;Nyelvi eszközök 1
4;;6;;Mi történik a háttérben egy auto-implementált property (pl. public string Name { get; set; }) létrehozásakor?;;A fordító egy publikus tagváltozót hoz létre;;Nem jön létre tagváltozó, az érték a veremben tárolódik;;A fordító generál egy rejtett, privát tagváltozót a property számára;;A property egy statikus változóhoz kötődik automatikusan;;C;;Nyelvi eszközök 1
5;;7;;Milyen módokon adható érték egy csak olvasható (readonly) auto-implementált tulajdonságnak (pl. public string Name { get; })?;;Bármelyik metódusból a 'set' kulcsszóval;;Kizárólag a konstruktorban vagy a deklaráció helyén, kezdőértékkel;;Kizárólag statikus metódusokból adható neki érték;;A 'get' ágon belülről, rekurzív módon;;B;;Nyelvi eszközök 1
6;;5;;Mit definiálunk a 'delegate' kulcsszó használatával C#-ban?;;Egy konkrét metódus implementációt;;Egy eseménykezelő láncot, ami automatikusan lefut;;Egy típust, ami egy adott szignatúrájú metódusra tud hivatkozni;;Egy absztrakt osztályt, aminek nincsenek tagváltozói;;C;;Nyelvi eszközök 1
7;;6;;Hogyan lehet egy delegate objektumhoz több metódusreferenciát is hozzáadni (multicast)?;;A 'new' kulcsszóval minden új metódusnál;;A metódusokat vesszővel elválasztva a konstruktorban;;A '+=' operátor használatával;;A 'Delegate.Add' statikus metódus hívásával;;C;;Nyelvi eszközök 1
8;;6;;Melyik a helyes módja egy delegate objektum által hivatkozott metódus meghívásának?;;A delegate objektumot úgy hívjuk, mintha egy függvény lenne;;A delegate '.Call()' metódusát kell használni;;A 'InvokeDelegate' kulcsszót kell használni;;A delegate-et nem lehet közvetlenül hívni, csak eseményen keresztül;;A;;Nyelvi eszközök 1
9;;5;;Milyen tervezési mintára épül a .NET eseménykezelési mechanizmusa?;;A Singleton (egykepéldányos) mintára;;A Factory (gyártó) mintára;;A Publisher/Subscriber (kiadó/feliratkozó) mintára;;A Decorator (dekorátor) mintára;;C;;Nyelvi eszközök 1
10;;4;;Mi a szerepe az 'event' kulcsszónak egy delegate típusú tagváltozó előtt?;;Jelzi, hogy a delegate csak egyetlen metódusra hivatkozhat;;Speciális védelmet ad a delegate-nek, eseménnyé alakítja;;Növeli a delegate teljesítményét a gyorsabb hívás érdekében;;Lehetővé teszi a delegate-nek, hogy értéket adjon vissza;;B;;Nyelvi eszközök 1
11;;7;;Miért fontos ellenőrizni egy eseményt (pl. Log) null értékre, mielőtt elsütjük?;;Mert ha nincs feliratkozó, az esemény null, és a hívása kivételt dob;;Hogy elkerüljük a végtelen ciklust a feliratkozók között;;Hogy a feliratkozók sorrendjét ellenőrizzük a hívás előtt;;Mert a null eseményhívás memóriaszivárgást okozhat;;A;;Nyelvi eszközök 1
12;;8;;Melyik állítás NEM igaz az 'event' és a 'delegate' közötti különbségre?;;Az event-et csak a tartalmazó osztályból lehet elsütni;;Az event-re nem lehet az '=' operátorral új hivatkozást adni;;Az event-re a '+=' és '-=' operátorokkal lehet fel- és leiratkozni;;Az event lehet lokális változó egy metóduson belül, a delegate nem;;D;;Nyelvi eszközök 1
13;;6;;Hogyan lehet leiratkozni egy eseményről C#-ban?;;A '-=' operátorral, megadva a korábban regisztrált kezelőfüggvényt;;Az '=' operátorral, null értéket adva az eseménynek;;A 'dispose' metódus meghívásával az eseményen;;A 'remove' kulcsszóval és az esemény nevével;;A;;Nyelvi eszközök 1
14;;5;;Mi az attribútumok (pl. [Serializable]) elsődleges funkciója a C# kódban?;;Futásidejű logikát adnak a kódelemekhez;;Deklaratív módon metaadatokat csatolnak a kódelemekhez;;Helyettesítik az öröklődést a kompozícióval;;Optimalizálják a fordító által generált IL kódot;;B;;Nyelvi eszközök 1
15;;7;;Melyik attribútummal jelezhetjük, hogy egy metódus elavult és használata nem javasolt?;;A [Deprecated] attribútummal;;A [NonSerialized] attribútummal;;Az [Obsolete] attribútummal;;A [Warning] attribútummal;;C;;Nyelvi eszközök 1
16;;4;;Az előadás alapján melyik az érték típus (value type)?;;string;;File;;struct;;interface;;C;;Nyelvi eszközök 1
17;;4;;Az előadás alapján melyik a referencia típus (reference type)?;;int;;bool;;class;;enum;;C;;Nyelvi eszközök 1
18;;6;;Mi a különbség egy `Person p1;` deklarációban, ha a Person egy 'struct' vagy egy 'class'?;;'struct' esetén null referencia, 'class' esetén létrejön az objektum;;Mindkét esetben létrejön az objektum alapértelmezett értékekkel;;Mindkét esetben csak egy null referencia jön létre a heap-en;;'struct' esetén létrejön az objektum, 'class' esetén csak egy null értékű referencia;;D;;Nyelvi eszközök 1
19;;5;;Hol foglal helyet egy lokális változóként deklarált 'struct' és 'class' példány?;;Mindkettő a heap-en (felügyelt memória);;A 'struct' a vermen (stack), a 'class' objektuma a heap-en;;Mindkettő a vermen (stack) a gyors elérés érdekében;;A 'class' a vermen (stack), a 'struct' a heap-en;;B;;Nyelvi eszközök 1
20;;6;;Mikor érdemes 'struct'-ot használni 'class' helyett az előadás szerint?;;Nagy, bonyolult adatszerkezetek modellezésére;;Amikor öröklődésre van szükségünk;;Kisméretű, adatszerű objektumok esetén a GC terhelésének csökkentésére;;Amikor az objektumainkat szálbiztosan kell kezelni;;C;;Nyelvi eszközök 1
21;;7;;Mit jelent a null-conditional operator (?.), pl. `Log?.Invoke(msg)` esetén?;;Ha a Log null, akkor kivételt dob;;Ha a Log null, akkor a program leáll;;Ha a Log nem null, akkor meghívja az Invoke metódust, különben nem csinál semmit;;Ha a Log nem null, akkor igaz logikai értékkel tér vissza;;C;;Nyelvi eszközök 1
22;;6;;Mi a különbség egy `Person[] persons = new Person[10];` tömblétrehozásnál, ha a Person `struct` vagy `class`?;;Semmi, a fordító mindkét esetben ugyanazt a kódot generálja;;struct esetén létrejön 10 objektum, class esetén csak 10 null referencia;;class esetén létrejön 10 objektum, struct esetén csak 10 üres referencia;;Mindkét esetben létrejön 10 objektum, de a class esetén a heap-en;;B;;Nyelvi eszközök 1
23;;7;;Milyen mechanizmussal lehet futásidőben lekérdezni egy osztály attribútumait?;;Szerializációval;;Delegátumokkal;;Reflection (reflexió) segítségével;;Pointer aritmetikával;;C;;Nyelvi eszközök 1
24;;5;;Hogyan lehet egy auto-implementált property-nek alapértelmezett értéket adni?;;A konstruktorban a 'default' kulcsszóval;;A deklaráció során az egyenlőségjel után megadva az értéket;;A get ágban egy if-else szerkezettel;;Nem lehet nekik alapértelmezett értéket adni;;B;;Nyelvi eszközök 1
25;;7;;Miért nem célszerű publikussá tenni egy osztály tagváltozóit az előadás szerint?;;Mert a publikus tagváltozók lassabbak, mint a property-k;;Mert nem garantálható az objektum konzisztens állapota;;Mert a publikus tagváltozókat a GC nem tudja felszabadítani;;Mert a publikus tagváltozók nem lehetnek statikusak;;B;;Nyelvi eszközök 1
26;;6;;Milyen néven érhető el a 'set' ágon belül az az érték, amit a property-nek be akarunk állítani?;;A 'data' nevű speciális változóban;;Az 'input' nevű beépített paraméterben;;A 'value' nevű implicit kulcsszóval;;A property nevével megegyező változóban;;C;;Nyelvi eszközök 1
27;;8;;Lehet-e egy property get és set ágának különböző a láthatósága?;;Nem, a property egészére csak egy láthatóság vonatkozhat;;Igen, de csak a get ág lehet szigorúbb (pl. private);;Igen, de csak a set ág lehet szigorúbb (pl. private);;Igen, bármelyik ág lehet szigorúbb vagy lazább is;;C;;Nyelvi eszközök 1
28;;6;;Melyik alternatív megoldás létezik a delegate-alapú összehasonlításra egy rendező algoritmusban?;;Az elemeknek implementálniuk kell az IComparable interfészt;;Az elemeknek implementálniuk kell a ISerializable interfészt;;Az elemeknek rendelkezniük kell egy 'SortKey' nevű property-vel;;Minden elemnek statikus 'Compare' metódussal kell rendelkeznie;;A;;Nyelvi eszközök 1
29;;5;;Milyen típusú metódusokra hivatkozhat egy delegate?;;Csak statikus metódusokra;;Csak nem statikus (példány) metódusokra;;Statikus és nem statikus metódusokra is;;Csak olyan metódusokra, amik ugyanabban az osztályban vannak;;C;;Nyelvi eszközök 1
30;;7;;Mi az alapja a .NET eseménykezelésének, ami a háttérben működik?;;Egy speciális, 'event' típusú objektum;;Egy multicast delegátból képzett speciális tagváltozó;;Egy láncolt lista, ami a feliratkozókat tárolja;;Egy beépített rendszerüzenet-sor (message queue);;B;;Nyelvi eszközök 1
31;;6;;Hogyan adhatunk át egy metódusreferenciát egy delegate-nek az egyszerűsített szintaktikával?;;A 'new' kulcsszóval és a metódus nevével;;Egyszerűen csak megadjuk a metódus nevét a delegate-nek értékül;;A metódus nevét stringként, idézőjelek között adjuk át;;Lambda kifejezéssel, ami meghívja a metódust;;B;;Nyelvi eszközök 1
32;;7;;A `[NonSerialized]` attribútum mit jelez a szerializációs folyamat számára?;;Hogy az egész osztályt nem szabad szerializálni;;Hogy az adott mezőt ki kell hagyni a szerializációból;;Hogy a mezőt titkosítva kell a stream-be írni;;Hogy a mező értéke null, és ezért nem érdemes elmenteni;;B;;Nyelvi eszközök 1
1;;3;;Milyen esetben használható a 'var' kulcsszó C#-ban?;;Csak osztályok tagváltozóinak deklarálásakor;;Függvények paramétereinek típusmegadása helyett;;Kizárólag lokális változók deklarálásakor, ha a fordító ki tudja következtetni a típust;;Bármilyen változó deklarálásakor a típus explicit megadása helyett;;C;;Nyelvi eszközök 2
2;;6;;Mi a legnagyobb teljesítménybeli probléma az 'object' alapú gyűjtemények (pl. ArrayList) használatakor érték típusokkal?;;A kötelező típuskonverzió (castolás) futási idejű hibákat okoz;;A be- és kidobozolás (boxing/unboxing) művelete, ami hely- és időigényes;;Az 'object' típus nem támogatja a 'ToString()' metódust;;Az ilyen gyűjtemények mérete nem növekedhet dinamikusan;;B;;Nyelvi eszközök 2
3;;5;;Melyik problémát NEM oldják meg a generikus típusok az 'object' alapú gyűjteményekkel szemben?;;Fordítási idejű típusbiztonságot nyújtanak;;Nincs szükség felesleges típuskonverziókra (castolásra);;Megszüntetik a boxing/unboxing szükségességét érték típusoknál;;Lehetővé teszik a null értékek tárolását a gyűjteményben;;D;;Nyelvi eszközök 2
4;;7;;Hogyan különbözik a .NET generikusok és a C++ sablonok (template) fordítása?;;A .NET generikusok futásidőben, a C++ sablonok fordításidőben fejtődnek ki;;A .NET generikusok lefordulnak IL kódra, a C++ sablonok csak felhasználáskor;;A C++ sablonokból IL kód lesz, a .NET generikusokból natív kód;;Nincs lényegi különbség, mindkettő ugyanazon az elven működik;;B;;Nyelvi eszközök 2
5;;6;;Mi a helyes szintaxis egy generikus `List<T>` használatára `int` típusú elemekkel?;;List<T> list = new List<int>();;;List<int> list = new List<int>();;;List list = new List<int>();;;List(int) list = new List(int)();;;B;;Nyelvi eszközök 2
6;;4;;Melyik NEM lehet generikus a .NET-ben az előadás alapján?;;Osztály (class);;Metódus (művelet);;Névtér (namespace);;Interfész (interface);;C;;Nyelvi eszközök 2
7;;5;;Melyik a .NET beépített generikus gyűjteménye kulcs-érték párok tárolására?;;List<K,V>;;Stack<K,V>;;Dictionary<K,V>;;HashSet<K,V>;;C;;Nyelvi eszközök 2
8;;6;;Melyik beépített generikus interfész szükséges ahhoz, hogy egy gyűjtemény bejárható legyen `foreach` ciklussal?;;IEnumerable<T>;;ICollection<T>;;IList<T>;;IReadOnlyList<T>;;A;;Nyelvi eszközök 2
9;;7;;Mire szolgál a `where T : class` generikus kényszer?;;A T típusparaméter csak `struct` lehet;;A T típusparaméter csak referencia típus lehet;;A T típusparaméternek implementálnia kell a `class` interfészt;;A T típusparaméternek rendelkeznie kell paraméter nélküli konstruktorral;;B;;Nyelvi eszközök 2
10;;8;;Mit kényszerít ki a `where T : new()` megszorítás egy generikus típuson?;;A T típusnak statikusnak kell lennie;;A T típusból nem lehet új példányt létrehozni;;A T típusnak rendelkeznie kell egy publikus, paraméter nélküli konstruktorral;;A T típusnak referencia típusnak kell lennie;;C;;Nyelvi eszközök 2
11;;3;;Mi a C#-ban használt lambda operátor?;;A '->' nyíl;;"A '=>' ""következik"" jel";;A '::' kettős kettőspont;;A 'lambda' kulcsszó;;B;;Nyelvi eszközök 2
12;;6;;Milyen típusú változónak lehet értékül adni egy lambda kifejezést?;;Bármilyen 'object' típusú változónak;;Egy, a lambda szignatúrájával kompatibilis delegate típusnak;;Egy, a lambda szignatúrájával megegyező interfésznek;;Egy 'Lambda' nevű speciális típusnak;;B;;Nyelvi eszközök 2
13;;7;;Mi a fő különbség az utasítás (statement) és a kifejezés (expression) lambda között?;;Az utasítás lambda nem adhat vissza értéket, a kifejezés igen;;A kifejezés lambda egyetlen kifejezésből áll, és nincs benne 'return' kulcsszó;;Az utasítás lambda csak egyetlen utasítást tartalmazhat;;A kifejezés lambda csak matematikai műveleteket végezhet;;B;;Nyelvi eszközök 2
14;;5;;Melyik beépített generikus delegate típus használatos értékvisszaadással rendelkező függvényekhez?;;Action<T>;;Predicate<T>;;Func<T, TResult>;;EventHandler<T>;;C;;Nyelvi eszközök 2
15;;6;;Melyik beépített generikus delegate típus használatos olyan függvényekhez, amelyek nem adnak vissza értéket (void)?;;Func<T>;;Action<T>;;VoidFunc<T>;;Procedure<T>;;B;;Nyelvi eszközök 2
16;;7;;Egy `Func<string, int, bool>` delegate esetében melyik a visszatérési típus?;;A 'string' típus;;Az 'int' típus;;A 'bool' típus;;Nincs visszatérési értéke;;C;;Nyelvi eszközök 2
17;;8;;"Mit jelent a ""variable capturing"" (vagy closure) a lambda kifejezések esetén?";;A lambda csak a saját paramétereit használhatja fel;;A lambda lemásolja a külső változók értékét a létrehozásakor;;"A lambda ""látja"" és használhatja a kontextusában lévő lokális változókat";;A lambda csak globális és statikus változókhoz férhet hozzá;;C;;Nyelvi eszközök 2
18;;5;;Mire használható a LINQ `Where` kiterjesztési metódus?;;Egy gyűjtemény elemeinek sorbarendezésére;;Egy gyűjtemény elemeinek szűrésére egy feltétel alapján;;Egy gyűjtemény minden elemének átalakítására (projekció);;Egy gyűjtemény elemeinek megszámlálására;;B;;Nyelvi eszközök 2
19;;6;;Mire használható a LINQ `Select` kiterjesztési metódus?;;A gyűjtemény első elemének kiválasztására;;A gyűjtemény elemeinek egyedi halmazzá alakítására;;A gyűjtemény elemeinek sorbarendezésére;;A gyűjtemény elemeinek átalakítására egy új formára (projekció);;D;;Nyelvi eszközök 2
20;;7;;"Mit jelent a LINQ esetében a ""késleltetett végrehajtás"" (deferred execution)?";;A LINQ műveletek azonnal lefutnak és az eredményt egy listában tárolják;;A LINQ lekérdezés csak akkor hajtódik végre, amikor az eredményre ténylegesen szükség van;;A LINQ műveletek mindig egy külön szálon futnak a háttérben;;A LINQ lekérdezések csak egyszer futtathatók le;;B;;Nyelvi eszközök 2
21;;4;;Mire szolgál a `partial` kulcsszó egy osztály definíciójánál?;;Az osztály egy részleges, absztrakt implementációját hozza létre;;Lehetővé teszi az osztály definíciójának több forrásfájlra való szétbontását;;Azt jelzi, hogy az osztály csak részben kompatibilis más .NET nyelvekkel;;Lehetővé teszi az osztály példányainak részleges inicializálását;;B;;Nyelvi eszközök 2
22;;6;;Mi a kifejezéstörzsű tagok (expression-bodied members) használatának fő előnye?;;Nagyobb futásidejű teljesítményt biztosítanak;;Lehetővé teszik lambda kifejezések használatát metódusokban;;Tömörebb, rövidebb szintaxist biztosítanak egyszerű, egy kifejezésből álló tagokhoz;;Automatikusan szálbiztossá teszik a metódust vagy a property-t;;C;;Nyelvi eszközök 2
23;;5;;Mire szolgál az objektuminicializáló (object initializer) szintaxis?;;Egy osztály konstruktorának helyettesítésére;;Publikus tulajdonságok és mezők beállítására az objektum létrehozásakor egy kifejezésben;;Anonim típusú objektumok létrehozására;;Objektumok szerializálására JSON formátumba;;B;;Nyelvi eszközök 2
24;;7;;Milyen típusú delegate-et vár a `Where` LINQ metódus paraméterként?;;`Action<T>`, ami minden elemen végrehajt egy műveletet;;`Func<T, bool>`, ami minden elemre visszaad egy logikai értéket;;`Func<T, T, bool>`, ami két elemet hasonlít össze;;`Predicate<T, T>`, ami egy speciális összehasonlító predikátum;;B;;Nyelvi eszközök 2
25;;8;;Egy lambda paraméterlistájában mikor hagyható el a zárójel?;;Amikor a lambda egyetlen kifejezésből áll;;Soha, a zárójel mindig kötelező a paraméterek körül;;Amikor pontosan egy paraméter van, és a típusa kikövetkeztethető;;Amikor nincsenek paraméterek;;C;;Nyelvi eszközök 2
26;;7;;Mi a szerepe az `ICollection<T>` interfésznek az `IEnumerable<T>`-hez képest?;;Csak annyi, hogy a gyűjtemény csak olvasható;;Lehetővé teszi az elemek index alapján történő elérését;;Tartalmazza az elemek hozzáadására és eltávolítására szolgáló metódusokat is;;Biztosítja a gyűjtemény elemeinek gyors sorbarendezését;;C;;Nyelvi eszközök 2
27;;8;;Melyik generikus kényszer kombináció biztosítja, hogy `T` egy interfész és van publikus konstruktora?;;`where T : interface, new()`;;`where T : IInterface, struct`;;`where T : class, IComparable`;;`Ilyen kombináció nem lehetséges, mert interfész nem példányosítható`;;D;;Nyelvi eszközök 2
28;;6;;Mi a különbség a `List<T>` és a `ReadOnlyCollection<T>` között?;;A `List<T>` nem módosítható, míg a `ReadOnlyCollection<T>` igen;;"A `ReadOnlyCollection<T>` egy `List<T>`-re néző, csak olvasható ""burok""";;A `ReadOnlyCollection<T>` gyorsabb, de kevesebb elemet tárolhat;;A `List<T>` érték típus, a `ReadOnlyCollection<T>` referencia típus;;B;;Nyelvi eszközök 2
29;;5;;Ha egy lambda kifejezés `()`-lel kezdődik, mit jelent az?;;A lambda egy konstruktort hív meg;;A lambda egyetlen, `()` nevű paramétert vár;;A lambdának nincsenek bemenő paraméterei;;Ez egy szintaktikai hiba;;C;;Nyelvi eszközök 2
30;;7;;Melyik művelet hatására hajtódik végre ténylegesen egy LINQ lekérdezés?;;A `Where` vagy `Select` metódusok hívásakor;;Amikor az eredményt egy `IEnumerable<T>` változóhoz rendeljük;;Amikor az eredményhalmazon elkezdünk iterálni (pl. `foreach` vagy `.ToList()`);;Amikor a forrás gyűjteményhez új elemet adunk;;C;;Nyelvi eszközök 2
1;;4;;Mire való elsődlegesen a WinUI 3 technológia?;;Multi-platform mobilalkalmazások fejlesztésére;;Desktop alkalmazások fejlesztésére Windows platformra;;Webes felületek készítésére Blazor segítségével;;Adatbázis-kezelő rendszerek programozására;;B;;WinUI
2;;6;;Melyik XAML dialektusra épül a WinUI 3?;;A WPF XAML dialektusára, teljes kompatibilitással;;A Xamarin.Forms XAML dialektusára;;Az UWP XAML dialektusára;;Egy teljesen új, egyedi XAML dialektusra;;C;;WinUI
3;;3;;Mit képviselnek általában a XAML tegek, mint például a <Button>?;;Egy metódushívást a code-behind fájlban;;Egy statikus változó deklarációját;;Egy osztály példányosítását;;Egy névtér importálását;;C;;WinUI
4;;5;;"Mire szolgálnak a XAML attribútumok, mint például a `Text=""Hello""`?";;Az elemhez tartozó eseménykezelőket definiálják;;Az elem típusát határozzák meg;;Az elem tulajdonságainak (property) beállítására;;Az elem egyedi azonosítóját adják meg;;C;;WinUI
5;;5;;Melyik NEM egy XAML-alapú multi-platform keretrendszer az előadás alapján?;;.NET MAUI;;Avalonia;;UNO Platform;;Windows Forms;;D;;WinUI
6;;6;;Hogyan lehet összetett tartalmat elhelyezni egy Button-ban a komponálhatóság elve szerint?;;A Button csak egyszerű szöveget tud megjeleníteni;;A `ComplexContent` property-nek kell átadni a tartalmat;;Más vezérlőket, pl. StackPanel-t és TextBlock-ot lehet a tartalmába ágyazni;;Egy speciális, `ButtonContent` nevű osztályt kell létrehozni;;C;;WinUI
7;;5;;Melyik XAML vezérlő szolgál más vezérlők táblázatos elrendezésére?;;A StackPanel;;A Canvas;;A Grid;;A ViewBox;;C;;WinUI
8;;7;;Hogyan adhatunk meg egy összetett tulajdonságot (pl. transzformáció) XAML-ben?;;<Border.RenderTransform> szintaxissal, mint külön XML csomópont;;A `composite-property` attribútummal;;A tulajdonság nevét és az objektumot stringként összefűzve;;Ezt csak a C# kódból lehet beállítani;;A;;WinUI
9;;4;;"Mire szolgál a `code-behind` fájl (pl. MainWindow.xaml.cs)?;;A XAML felület stílusdefinícióit tartalmazza";;Az alkalmazás üzleti logikáját és adatmodelljét tárolja;;A XAML-ben definiált felülethez tartozó logikát, pl. eseménykezelőket tartalmazza;;A fordító által generált, ideiglenes fájlokat tartalmazza;;C;;WinUI;;
10;;5;;Milyen szintaxissal aktiválunk egy `markup` kiterjesztést egy tulajdonság megadásánál?;;A `[...]` szögletes zárójelekkel;;A `{...}` kapcsos zárójelekkel;;A `$(...)` dollárjel és zárójelekkel;;A `markup:` előtaggal a tulajdonság előtt;;B;;WinUI
11;;6;;Melyik ősosztályból származik a legtöbb vezérlő, ami egyetlen tartalmi elemet (Content) képes megjeleníteni?;;ItemsControl;;Selector;;ContentControl;;ButtonBase;;C;;WinUI
12;;6;;Melyik ősosztályból származnak azok a vezérlők, amelyek egy elemlistát (items) képesek megjeleníteni?;;ContentControl;;ItemsControl;;Panel;;Selector;;B;;WinUI
13;;5;;Mi a fő különbség a TextBlock és a TextBox között?;;A TextBlock formázott szöveget jelenít meg, a TextBox egy szerkeszthető szövegdoboz;;A TextBox csak egysoros, míg a TextBlock többsoros lehet;;A TextBlock csak számokat, a TextBox csak szöveget tud megjeleníteni;;A TextBlock interaktív, a TextBox csak statikus szöveget jelenít meg;;A;;WinUI
14;;7;;Hogyan dönti el egy `ContentControl`, hogy a `Content` property-ben lévő objektumot hogyan jelenítse meg?;;Mindig a ToString() metódus eredményét írja ki;;Ha van hozzá `ContentTemplate`, azt használja, egyébként a ToString()-et;;A tartalom típusa alapján automatikusan generál egy felületet;;Kizárólag UIElement típusú objektumokat tud megjeleníteni;;B;;WinUI
15;;7;;Miért használnak a XAML-alapú keretrendszerek `DependencyProperty`-t a hagyományos C# property-k helyett?;;Mert kevesebb memóriát foglalnak, és támogatják az adatkötést, stílusokat, animációt;;Mert a `DependencyProperty`-k gyorsabbak a számításigényes feladatokban;;Mert a hagyományos property-ket nem lehet XAML-ből elérni;;Mert a `DependencyProperty` egy követelmény az XML szabvány részéről;;A;;WinUI
16;;8;;Mi a `DependencyObject` szerepe a `DependencyProperty` rendszerben?;;Ez a `DependencyProperty`-k típusát leíró osztály;;Ez a `DependencyProperty`-k metaadatait tároló osztály;;Ez egy kulcs-érték tároló, ami a vezérlő beállított `DependencyProperty`-jeit tárolja;;Ez egy eseménykezelő a `DependencyProperty` változásainak lekezelésére;;C;;WinUI
17;;7;;Mit nevezünk `attached property`-nek? (pl. `Canvas.Left`);;Egy olyan property, ami a vezérlőhöz csatolt adatbázisban tárolódik;;Egy olyan property, ami a saját típusán kívül más objektumokon is beállítható;;Egy olyan property, ami csak a `code-behind` fájlból érhető el;;Egy olyan property, ami futásidőben dinamikusan jön létre;;B;;WinUI
18;;6;;"Mi történik, ha egy vezérlő `Width`-je fixen ""100"", a `HorizontalAlignment`-je pedig `Stretch`?";;A vezérlő kitölti a rendelkezésre álló helyet, a 100-as szélességet figyelmen kívül hagyja;;A `Stretch` felülírja a `Width`-et, és a vezérlő mérete 0 lesz;;A vezérlő szélessége 100 lesz, és a `Stretch` miatt középre kerül a szülőben;;Fordítási hiba keletkezik, mert a `Width` és a `Stretch` kizárják egymást;;C;;WinUI
19;;5;;Melyik panel helyezi el a gyerek elemeket egymás alá vagy mellé egyetlen sorban/oszlopban?;;Grid;;Canvas;;RelativePanel;;StackPanel;;D;;WinUI
20;;6;;Melyik panel teszi lehetővé az elemek pontos, pixel-alapú koordinátákkal történő elhelyezését?;;Grid;;Canvas;;StackPanel;;VariableSizedWrapGrid;;B;;WinUI
21;;7;;Hogyan lehet a `Grid`-ben egy sort úgy definiálni, hogy az a benne lévő tartalom magasságához igazodjon?;;A `RowDefinition Height` tulajdonságát `Stretch`-re kell állítani;;A `RowDefinition Height` tulajdonságát `Auto`-ra kell állítani;;A `RowDefinition`-nek nem kell `Height`-et adni, ez az alapértelmezett;;A `RowDefinition Height` tulajdonságát `*`-ra kell állítani;;B;;WinUI
22;;6;;Mire szolgál a `StaticResource` markup kiterjesztés?;;Egy statikus C# osztály példányosítására a XAML-ben;;Egy korábban, erőforrásként definiált objektumra (pl. stílus, szín) való hivatkozásra;;Egy külső fájl tartalmának beágyazására a XAML-be;;Egy statikus metódus meghívására a `code-behind`-ból;;B;;WinUI
23;;7;;Mi a különbség az implicit és explicit stílusok között?;;Az implicit stílus `x:Key` nélkül, `TargetType` alapján érvényesül minden megfelelő vezérlőn;;Az explicit stílusok automatikusan érvényesülnek, az impliciteket `x:Key`-jel kell megadni;;Az implicit stílusok nem örökölhetnek más stílusokból;;Az explicit stílusok gyorsabbak, de kevesebb tulajdonságot lehet bennük beállítani;;A;;WinUI
24;;5;;Melyik két fő szintaktikája van az adatkötésnek az előadás szerint?;;`{DataBind ...}` és `{Source ...}`;;`{x:Bind ...}` és `{Binding ...}`;;`{BindTo ...}` és `{DataSource ...}`;;`{Value ...}` és `{Path ...}`;;B;;WinUI
25;;7;;Mi a fő előnye az `{x:Bind}` használatának a `{Binding}`-gel szemben?;;Dinamikusabb, és futásidőben bármilyen adatforráshoz köthető;;Egyszerűbb a szintaktikája, kevesebb opcióval rendelkezik;;Fordítási időben típusellenőrzött, ami gyorsabb és biztonságosabb kódot eredményez;;A `{x:Bind}` a régebbi, elavult megoldás, a `{Binding}` a modernebb;;C;;WinUI
26;;6;;Melyik adatkötési mód (`Mode`) felelős a kétirányú adatáramlásért (UI változása frissíti a forrást és fordítva)?;;OneTime;;OneWay;;TwoWay;;OneWayToSource;;C;;WinUI
27;;8;;Milyen interfészt kell implementálnia egy adatforrás osztálynak, hogy a property-jeinek változásáról a UI automatikusan értesüljön?;;IValueConverter;;IDataSource;;INotifyPropertyChanged;;IEnumerable;;C;;WinUI
28;;8;;Mire szolgál az `IValueConverter` interfész az adatkötésben?;;Annak ellenőrzésére, hogy az adat érvényes-e;;Az adatforrás és a cél property közötti típus- vagy formátum-átalakításra;;Egy adatbázis-kapcsolat kezelésére;;Az adatkötési hibák naplózására;;B;;WinUI
29;;5;;Mi a sablonok (pl. `DataTemplate`) fő feladata a XAML-alapú rendszerekben?;;Az alkalmazás logikájának egységesítése;;Azonos típusú adatok egységes vizuális megjelenítésének definiálása;;Az alkalmazás biztonsági beállításainak központi tárolása;;A vezérlők közötti kommunikáció megvalósítása;;B;;WinUI
30;;6;;Melyik a három fő komponense az MVVM (Model-View-ViewModel) tervezési mintának?;;Model, View, Controller;;Model, View, Presenter;;Model, ViewModel, Service;;Model, View, ViewModel;;D;;WinUI
31;;7;;Az MVVM mintában melyik komponens felelős a megjelenítési logikáért és az állapot tárolásáért?;;A Model, mert az tartalmazza az adatokat;;A View, mert az jeleníti meg az állapotot;;A ViewModel, ami közvetít a Model és a View között;;A Code-behind, ami az eseményeket kezeli;;C;;WinUI
32;;8;;Szigorú MVVM esetén hogyan kommunikál a View a Modellel?;;Közvetlenül hívja a Model metódusait;;A View közvetlenül nem kommunikál a Modellel, csak a ViewModellel;;A Model eseményeire iratkozik fel;;Egy közös statikus osztályon keresztül;;B;;WinUI
33;;6;;Mire szolgál a `Command` minta az MVVM-ben?;;A View és ViewModel közötti adatáramlás biztosítására;;A felhasználói műveletek (pl. gombnyomás) és az azokat végrehajtó logika szétválasztására;;Az adatok adatbázisban történő perzisztens tárolására;;A különböző nézetek közötti navigáció kezelésére;;B;;WinUI
34;;9;;Hogyan lehet egyszerűen INPC implementációt és parancsokat generálni a `CommunityToolkit.Mvvm` segítségével?;;Manuálisan, minden property-hez és metódushoz kódot kell írni;;A `[ObservableProperty]` és `[RelayCommand]` attribútumok használatával;;A `GenerateMVVM` nevű statikus metódus meghívásával;;A projektfájlban kell egy speciális beállítást engedélyezni;;B;;WinUI
35;;6;;Melyik NEM az MVVM minta egyik előnye az előadás szerint?;;A felelősségek szétválasztása;;A kód könnyebb tesztelhetősége;;A legkisebb implementációs overhead, egyszerű alkalmazásoknál is megéri;;A kód jobb áttekinthetősége és karbantarthatósága;;C;;WinUI
1;;4;;Az alábbiak közül mi NEM tartozik egy folyamathoz (process) az operációs rendszerben?;;Saját, privát memória címtartomány;;Legalább egy végrehajtási szál (thread);;Más folyamatokkal közös memória címtartomány;;A folyamat által használt rendszererőforrások;;C;;Szálkezelés
2;;5;;Mi a folyamatok (process) egymástól való elszigeteltségének legfőbb oka és következménye?;;Azért, hogy gyorsabban tudjanak kommunikálni egymással;;Az operációs rendszer védelmet nyújt, így egy folyamat nem írhatja felül egy másik memóriáját;;Azért, hogy megoszthassák egymással a CPU magokat a hatékonyabb működésért;;Azért, hogy közösen használhassák ugyanazokat a rendszer DLL fájlokat;;B;;Szálkezelés
3;;3;;Mi a szál (thread) alapvető definíciója a konkurens programozásban?;;Egy teljesen önálló program, saját memóriával;;A futási/ütemezési alapegység egy folyamaton belül;;Egy memóriakezelő egység, ami a virtuális címeket kezeli;;Egy kommunikációs csatorna két folyamat között;;B;;Szálkezelés
4;;6;;Mi a többszálúság legfőbb előnye egy grafikus felületű (GUI) alkalmazásban?;;Lehetővé teszi, hogy a hosszú, blokkoló műveletek a háttérben fussanak, így a GUI reszponzív marad;;Jelentősen csökkenti az alkalmazás által felhasznált memória mennyiségét;;Egyszerűbbé teszi a kódot, mert nem kell eseménykezeléssel foglalkozni;;Automatikusan megakadályozza a kivételek keletkezését a felhasználói interakciók során;;A;;Szálkezelés
5;;5;;Miben különbözik alapvetően a szálak és a folyamatok közötti kommunikáció?;;A szálak közötti kommunikáció mindig lassabb, mert az OS felügyeli;;Egy folyamaton belüli szálak közös memóriaterületen osztoznak, így könnyebben kommunikálnak;;A folyamatok közötti kommunikációhoz nincs szükség operációs rendszeri támogatásra;;Nincs lényegi különbség, mindkettő ugyanazokat a hálózati protokollokat használja;;B;;Szálkezelés
6;;4;;Melyik metódus hívása indítja el ténylegesen egy `new Thread(func)`-kal létrehozott szál végrehajtását?;;A `t.Run()` metódus hívása;;A `t.Execute()` metódus hívása;;A `t.Start()` metódus hívása;;A `t.BeginInvoke()` metódus hívása;;C;;Szálkezelés
7;;5;;Milyen típusú delegate-et vár a `Thread` osztály konstruktora paraméter nélküli szálindításhoz?;;Action delegate-et;;ThreadStart delegate-et;;ParameterizedThreadStart delegate-et;;Func delegate-et;;B;;Szálkezelés
8;;6;;Mit eredményez, ha egy szál `IsBackground` tulajdonságát `true`-ra állítjuk?;;A szál magasabb prioritást kap, és gyorsabban fut;;A processzus (az alkalmazás) akkor is leáll, ha ez a háttérszál még fut;;A szál egy külön CPU magon fog futni, elkülönítve a főszáltól;;A processzus csak akkor léphet ki, ha az összes háttérszál befejezte a futását;;B;;Szálkezelés
9;;4;;Melyik statikus metódussal lehet az aktuális szál végrehajtását egy adott időre felfüggeszteni?;;Thread.Wait(millisec);;Thread.Pause(millisec);;Thread.Stop(millisec);;Thread.Sleep(millisec);;D;;Szálkezelés
10;;7;;Hogyan kell kezelni egy szálban keletkező kivételt, hogy az indító szál tudomást szerezzen róla?;;Az indító szál köré írt try-catch blokk automatikusan elkapja a másik szál kivételét;;A kivételt a szálban kell elkapni, és egy közös, szálbiztos mechanizmuson keresztül jelezni;;A szálban dobott kivétel automatikusan leállítja a teljes alkalmazást;;A `Thread.Start()` metódus egy `Exception` objektummal tér vissza hiba esetén;;B;;Szálkezelés
11;;6;;Mi a kölcsönös kizárás (mutual exclusion) problémájának lényege többszálú környezetben?;;Amikor két szál ugyanazt a CPU magot akarja használni egyszerre;;Amikor több szál egyszerre próbál hozzáférni egy megosztott erőforráshoz, ami versenyhelyzetet okoz;;Amikor egy szál túl sok memóriát foglal le, és a többi nem tud elindulni;;Amikor egy folyamat nem tud új szálat indítani, mert elérte a maximális szál-limitet;;B;;Szálkezelés
12;;7;;Mi a probléma az "aktív várakozással" (busy waiting), például egy `while(flag)` ciklussal?;;Rendkívül erőforrás-igényes, mert feleslegesen terheli a CPU-t 100%-on;;Nem szálbiztos, és könnyen versenyhelyzetet okozhat;;Csak egyetlen szál tudja használni, több szál esetén holtpontot okoz;;Az operációs rendszer nem támogatja, és kivételt dob;;A;;Szálkezelés
13;;5;;Melyik a kritikus szakasz (critical section) definíciója?;;A programnak az a része, ami a legtöbb CPU időt használja;;A kódnak az a része, amelyben a szál létrehozása és indítása történik;;A kódnak az a része, amelyben a program a felhasználótól vár inputot;;A kódrészlet, amelyben megosztott erőforráshoz férünk hozzá, és ahol kölcsönös kizárás szükséges;;D;;Szálkezelés
14;;4;;Mire szolgál a `lock (syncObject)` utasítás a C# nyelvben?;;Egy objektum lezárására, hogy azt ne lehessen törölni a memóriából;;Egy kódrészlet (kritikus szakasz) védelmére, hogy egyszerre csak egy szál futtathassa;;Egy szál prioritásának ideiglenes megemelésére;;Egy változó értékének véglegesítésére, hogy az többé ne legyen módosítható;;B;;Szálkezelés
15;;8;;Mi lehet szinkronizációs objektum a `lock` utasítás paramétereként?;;Bármilyen `struct` típusú változó;;Bármilyen `bool` vagy `int` típusú változó;;Bármilyen referencia típusú (osztály) objektum;;Csak a `System.Threading.Mutex` osztály egy példánya;;C;;Szálkezelés
16;;7;;Mire fordítja le a C# fordító a `lock (syncObject) { ... }` blokkot?;;Egy `if (syncObject == null)` ellenőrzésre;;`Monitor.Enter(syncObject)` hívásra egy try blokkban és `Monitor.Exit(syncObject)` hívásra a finally blokkban;;Egy `Mutex.WaitOne()` és `Mutex.ReleaseMutex()` hívás párra;;Egy `while(syncObject.IsLocked)` ciklusra;;B;;Szálkezelés
17;;9;;Hogyan kell helyesen védeni egy nem statikus és egy statikus tagváltozót egy osztályon belül?;;Mindkettőt ugyanazzal a statikus szinkronizációs objektummal;;A nem statikust egy példányszintű, a statikust egy statikus szinkronizációs objektummal;;A nem statikust egy statikus, a statikust egy példányszintű szinkronizációs objektummal;;A lock utasítás automatikusan tudja, melyik változóról van szó, nem kell külön objektum;;B;;Szálkezelés
18;;6;;Miért nem szálbiztos/atomi a `x++` művelet?;;Mert a `++` operátor elavult a modern C#-ban;;Mert a fordító nem tudja lefordítani többszálú környezetben;;Mert a művelet valójában három lépésből áll: olvasás, növelés, visszaírás;;Mert a `++` művelet csak `volatile` mezőkön működik helyesen;;C;;Szálkezelés
19;;7;;Mire való a `System.Threading.Interlocked` osztály?;;Összetett adatszerkezetek, például listák zárolására;;Atomi (megszakíthatatlan) műveletek végrehajtására egyszerű numerikus típusokon;;Szálak közötti események küldésére és fogadására;;Szálak prioritásának dinamikus változtatására;;B;;Szálkezelés
20;;8;;Mikor van szükség a `volatile` kulcsszó használatára?;;Amikor egy változó értékét több szál is írhatja, és meg akarjuk akadályozni a fordítói optimalizációkat és a cache-elést;;Minden megosztott változó elé ki kell tenni a szálbiztosság érdekében;;Amikor egy változót a `lock` blokkon kívül szeretnénk használni;;Csak akkor, ha a változó 64 bites, és 32 bites rendszeren fut a program;;A;;Szálkezelés
21;;6;;Hogyan tud egy szál kulturáltan megvárni egy másik szál befejeződését?;;Egy `while(!otherThread.IsFinished)` ciklussal;;Az `otherThread.Join()` metódus meghívásával;;Az `otherThread.Sleep()` metódus meghívásával;;A `Mutex.WaitOne(otherThread.Handle)` hívással;;B;;Szálkezelés
22;;5;;Melyik NEM egy szinkronizációs zárolási konstrukció a .NET-ben?;;lock;;Mutex;;Semaphore;;AutoResetEvent;;D;;Szálkezelés
23;;6;;Mi a fő különbség az `AutoResetEvent` és a `ManualResetEvent` között?;;Az `AutoResetEvent` automatikusan nem-jelzett állapotba kerül egy várakozó szál feloldása után;;A `ManualResetEvent` automatikusan nem-jelzett állapotba kerül egy várakozó szál feloldása után;;Az `AutoResetEvent` több szálat is fel tud oldani egyszerre, a `ManualResetEvent` csak egyet;;A `ManualResetEvent` gyorsabb, de csak folyamatok között használható;;A;;Szálkezelés
24;;7;;Mire használható a `Semaphore` osztály?;;Két szál közötti adatcserére;;Annak korlátozására, hogy egy időben legfeljebb N számú szál férhessen hozzá egy erőforráshoz;;Egyetlen szál futásának felfüggesztésére és folytatására;;Egy esemény bekövetkeztének jelzésére egyetlen várakozó szál számára;;B;;Szálkezelés
25;;8;;WinUI alkalmazásokban melyik osztállyal lehet egy háttérszálból a UI szálon műveletet végrehajtani?;;A `System.Threading.Thread` osztállyal;;A `Microsoft.UI.Xaml.Window` osztállyal;;A `System.Windows.Forms.Application` osztállyal;;A `Microsoft.UI.Dispatching.DispatcherQueue` osztállyal;;D;;Szálkezelés
26;;6;;Mikor célszerű `ThreadPool`-t használni dedikált `Thread` indítása helyett?;;Hosszú, folyamatosan futó háttérfeladatokhoz, mint egy szerverfigyelő;;Sok, rövid ideig tartó feladat végrehajtására, a szál-létrehozási költségek elkerülése végett;;Amikor a szál prioritását `RealTime`-ra kell állítani;;Amikor a szálból GUI elemeket kell közvetlenül elérni;;B;;Szálkezelés
27;;7;;Melyik állapotba kerül egy szál, amikor a `lock`, `Join` vagy `WaitOne` metódusok valamelyikére vár?;;Running;;Stopped;;WaitSleepJoin;;Unstarted;;C;;Szálkezelés
28;;8;;Hogyan lehet egy `WaitSleepJoin` állapotban lévő szálat "felébreszteni" a várakozás megszakításával?;;A `Thread.Abort()` metódus hívásával;;A `Thread.Interrupt()` metódus hívásával;;A `Thread.Resume()` metódus hívásával;;A `Thread.WakeUp()` metódus hívásával;;B;;Szálkezelés
29;;5;;Mi a holtpont (deadlock) jelensége?;;Amikor egy szál kivételt dob, és nem kezeli le senki;;Amikor két vagy több szál kölcsönösen egymás által birtokolt erőforrásra vár, és így soha nem tudnak továbbhaladni;;Amikor egy szál túl sokáig fut, és elveszi a CPU-t a többi elől;;Amikor egy program több szálat indít, mint amennyi a CPU magok száma;;B;;Szálkezelés
30;;7;;Mi a holtpont elkerülésének leggyakoribb módja?;;Mindig használjunk `try-catch` blokkot a zárolások körül;;Csökkentsük a szálak prioritását, hogy ne versengjenek annyira;;Használjunk időkorlátot (timeout) a zárolásoknál;;Mindig ugyanabban a sorrendben kérjük el a zárakat minden szálban;;D;;Szálkezelés
1;;3;;Mi a programtervezési minta alapvető definíciója az előadás szerint?;;Egy konkrét kódrészlet, amit egy az egyben be lehet másolni a programba;;Gyakran előforduló programtervezési probléma és annak általános, újrafelhasználható megoldása;;Egy algoritmus, ami egy specifikus matematikai feladatot old meg hatékonyan;;Egy programozási nyelv, ami kifejezetten a szoftverfejlesztést segíti;;B;;Tervezési minták 1
2;;5;;Melyik NEM tartozik a tervezési minták leírásának négy alapvető eleme közé az előadásban?;;A probléma, amit a minta megold (problem);;A minta neve, ami azonosítja (pattern name);;A minta konkrét, futtatható kódja egy adott programnyelven;;A megoldás elemei és azok kapcsolatai (solution);;C;;Tervezési minták 1
3;;4;;A tervezési minták melyik szintjén vagy csoportjába tartoznak az idiómák (idioms)?;;Architekturális szint, ami az egész rendszer felépítését meghatározza;;Tervezési minta szint, ami a programnyelvektől független;;A legalacsonyabb szint, ami egy adott programozási nyelv sajátosságait használja ki;;A legmagasabb szint, ami a szoftverfejlesztési folyamatot írja le;;C;;Tervezési minták 1
4;;6;;Ki vagy kik írták a "Design Patterns: Elements of Reusable Object-Oriented Software" című alapművet?;;A "Gang of Four" (GoF), vagyis a négyek bandája;;A Microsoft fejlesztőcsapata a .NET keretrendszerhez;;Robert C. Martin a SOLID elvek megalkotója;;A Java programozási nyelv megalkotói a Sun Microsystemsnél;;A;;Tervezési minták 1
5;;5;;Melyik a három fő kategória, amibe a GoF (Gang of Four) a tervezési mintákat sorolja?;;Létrehozási, Szerkezeti, Viselkedési;;Funkcionális, Objektumorientált, Procedurális;;Architekturális, Tervezési, Idiomatikus;;Gyors, Hatékony, Memóriatakarékos;;A;;Tervezési minták 1
6;;6;;Melyik GoF kategóriába tartozik a Template Method (Sablonmetódus) és a Strategy (Stratégia) minta?;;Létrehozási (creational) minták;;Szerkezeti (structural) minták;;Viselkedési (behavioral) minták;;Architekturális (architectural) minták;;C;;Tervezési minták 1
7;;7;;Melyik magas szintű cél elérését NEM segítik közvetlenül a tervezési minták az előadás szerint?;;Könnyen változtatható, kiterjeszthető kód készítése;;Újrafelhasználható kód készítése;;Könnyen (unit) tesztelhető kód készítése;;A program futási idejének minimalizálása;;D;;Tervezési minták 1
8;;8;;Mi a "design for change" alapelve, ami a változtathatóságot és bővíthetőséget célozza?;;Minden kódot úgy kell írni, hogy a jövőben ne kelljen hozzányúlni;;Azon részeket kell elválasztani amik változhatnak, azoktól amik változatlanok;;A programot a lehető legtöbb "if-else" szerkezettel kell felépíteni;;A teljes programot egyetlen nagy osztályban kell implementálni a könnyebb átláthatóságért;;B;;Tervezési minták 1
9;;7;;Mit jelent az Open/Closed Principle a szoftvertervezésben?;;Az osztály kódja legyen nyílt forráskódú és bárki által módosítható;;Az osztály legyen nyitott a kiterjesztésre, de zárt a módosításra;;Az osztály metódusai legyenek nyitottak a felülírásra, de zártak a hívásra;;Minden osztály legyen zárt, hogy a későbbiekben ne változtathassák meg;;B;;Tervezési minták 1
10;;6;;Mi a Template Method (Sablonmetódus) tervezési minta alapvető célja?;;Algoritmusok futás közbeni cseréjének lehetővé tétele;;Egy algoritmus vázának definiálása egy ősosztályban, bizonyos lépések implementálását a leszármazottakra bízva;;Egy bonyolult alrendszer egyszerűsített interfészének biztosítása;;Biztosítani, hogy egy osztályból csak egyetlen példány jöjjön létre;;B;;Tervezési minták 1
11;;7;;Hogyan valósítja meg a Template Method minta az algoritmus vázát és a változó részeket?;;A vázat egy interfész, a változó részeket azt implementáló osztályok adják;;A vázat egy `final` metódus adja, ami absztrakt vagy virtuális metódusokat hív;;A vázat egy statikus segédosztály, a változó részeket delegátumok biztosítják;;A vázat egy konfigurációs fájlban, a változó részeket a kódban definiáljuk;;B;;Tervezési minták 1
12;;6;;Melyik állítás igaz a Template Method mintában szereplő sablonmetódusra?;;A sablonmetódus (pl. Run) tipikusan virtuális, hogy a leszármazottak felülírhassák;;A sablonmetódus (pl. Run) tartalmazza az algoritmus változatlan vázát;;A sablonmetódus (pl. Run) implementációja a leszármazott osztályokban történik;;A sablonmetódus (pl. Run) mindig privát láthatóságú, hogy ne lehessen felülírni;;B;;Tervezési minták 1
13;;7;;Mi a DRY (Don't Repeat Yourself) elv, és hogyan segíti ezt a Template Method?;;A közös, invariáns kódrészeket egy helyre, a szülő osztályba szervezi, elkerülve a kódduplikációt;;Azt jelenti, hogy egy algoritmust nem szabad kétszer implementálni ugyanabban az osztályban;;Megköveteli, hogy minden metódus csak egyetlen sort tartalmazzon a redundancia elkerülése végett;;Azt jelenti, hogy a változó kódrészeket nem szabad ismételni a leszármazottakban;;A;;Tervezési minták 1
14;;8;;Mi a Template Method minta egyik hátránya vagy korlátja?;;Nem teszi lehetővé a kód-újrafelhasználást, mert minden leszármazottban mindent újra kell írni;;Az algoritmus viselkedése nem változtatható meg futásidőben, csak új leszármazott létrehozásával;;Rendkívül bonyolulttá teszi a kódot, mert sok interfészt kell definiálni;;Nem támogatja a többszörös öröklődést, ezért használhatatlan;;B;;Tervezési minták 1
15;;5;;Milyen problémára ad rossz választ a Template Method, ha a viselkedésnek több aspektusa van?;;Ha csak egyetlen algoritmus létezik, és az sosem változik;;Ha a viselkedésbeli különbségek túl nagyok az ősosztályhoz képest;;Ha több, egymástól független viselkedési dimenzió van, ami kombinatorikus osztályrobbanáshoz vezet;;Ha az algoritmus lépései nagyon egyszerűek és rövidek;;C;;Tervezési minták 1
16;;6;;Mi a Strategy (Stratégia) tervezési minta alapvető célja?;;Egy algoritmus vázának definiálása, a lépések leszármazottakra bízva;;Algoritmusok egy családjának definiálása, egységbe zárása és egymással felcserélhetővé tétele;;Osztályok és objektumok összekapcsolása fa struktúrába a részek és egész modellezésére;;Strukturálisan különböző interfészek együttműködésének lehetővé tétele;;B;;Tervezési minták 1
17;;7;;Milyen viszony van a Context és a Strategy objektumok között a Strategy mintában?;;A Context öröklődik a Strategy-ből;;A Strategy tartalmaz egy referenciát a Context-re;;A Context tartalmaz egy referenciát a Strategy interfészre;;A Context és a Strategy teljesen függetlenek egymástól;;C;;Tervezési minták 1
18;;8;;Milyen alapvető programozási elvet testesít meg a Strategy minta?;;A "Program to an implementation, not an interface" elvet;;A "Favor inheritance over composition" elvet;;A "Program to an interface, not an implementation" elvet;;A "Single Responsibility Principle" megsértését;;C;;Tervezési minták 1
19;;7;;Milyen előnyt nyújt a Strategy minta a Template Method-dal szemben?;;Lehetővé teszi az algoritmusok (stratégiák) futás közbeni cseréjét;;Mindig kevesebb osztályt kell létrehozni a megvalósításához;;Egyszerűbb a megértése, mert nem használ interfészeket;;Jobb a teljesítménye, mert nem használ virtuális függvényhívásokat;;A;;Tervezési minták 1
20;;8;;Milyen szoftverfejlesztési elvet segít betartani a Strategy minta, amikor több felelősséget (pl. tömörítés, megszakítás) külön stratégiákba szervezünk?;;Az Open/Closed Principle (OCP) elvét;;A Single Responsibility Principle (SRP) elvét;;A Liskov Substitution Principle (LSP) elvét;;Az Interface Segregation Principle (ISP) elvét;;B;;Tervezési minták 1
21;;6;;Hogyan lehet a Strategy mintában a kliensnek (Context) átadni a konkrét stratégiát?;;A stratégia mindig fixen bele van égetve a kliens kódjába;;Paraméterként a kliens konstruktorában vagy egy setter metóduson keresztül;;A kliens egy factory segítségével maga hozza létre a megfelelő stratégiát;;A stratégia egy globális változóban van tárolva, amit a kliens elér;;B;;Tervezési minták 1
22;;8;;Milyen programozási mechanizmusra épül a Template Method és a Strategy minta?;;Mindkettő kizárólag öröklődésre épül;;Mindkettő kizárólag kompozícióra épül;;A Template Method kompozícióra, a Strategy öröklődésre épül;;A Template Method öröklődésre, míg a Strategy kompozícióra/delegálásra épül;;D;;Tervezési minták 1
23;;7;;Hogyan segíti a Strategy minta az egységtesztelést (unit testing)?;;Automatikusan generál teszteseteket minden stratégiához;;Lehetővé teszi, hogy a klienst (Context) teszteljük "dummy" vagy "mock" stratégia-implementációkkal;;Megnehezíti a tesztelést, mert a viselkedés futásidőben változik;;Minden stratégiát csak a klienssel együtt, integrációs teszt keretében lehet tesztelni;;B;;Tervezési minták 1
24;;4;;Melyik GoF minta NEM viselkedési minta az előadás felsorolása szerint?;;Template Method;;Strategy;;Observer;;Adapter;;D;;Tervezési minták 1
25;;6;;A bemutatott adatfeldolgozó példában mi volt a fő probléma az enum-alapú megoldással?;;Túl lassú volt a switch utasítás miatt;;Nem volt elég típusbiztos, futásidejű hibákat okozott;;Megsértette az Open/Closed elvet, mert új algoritmushoz módosítani kellett a meglévő kódot;;Túl sok memóriát használt, mert az enum minden eleme külön objektum;;C;;Tervezési minták 1
26;;7;;Mit jelent a "System of Patterns" fogalom?;;Azt, hogy egy programban csak egyetlen tervezési mintát szabad használni;;Azt, hogy a tervezési minták egy rendszert alkotnak, és gyakran együtt, egymást kiegészítve használjuk őket;;Egy operációs rendszert, ami kizárólag tervezési mintákból épül fel;;Egy könyvtárat, ami minden létező tervezési minta implementációját tartalmazza;;B;;Tervezési minták 1
27;;7;;Hogyan segíti a laza csatolást (loose coupling) a Strategy minta?;;A kliens (Context) nem ismeri a konkrét stratégia implementációját, csak az interfészt;;A kliens szorosan csatlakozik a konkrét stratégiához öröklődésen keresztül;;Minden stratégia osztály ismeri az összes többi stratégia osztályt;;A stratégia interfész minden lehetséges algoritmus metódusát tartalmazza;;A;;Tervezési minták 1
28;;8;;Mi a Template Method minta egyik fő negatív következménye a kódduplikáció elkerülése mellett?;;A leszármazott osztályok implementációja szorosan kötődik az ősosztályhoz;;A minta használata mindig futásidejű teljesítménycsökkenést okoz;;A minta nem alkalmas grafikus felhasználói felületek tervezésére;;Az ősosztálynak ismernie kell az összes lehetséges leszármazottat;;A;;Tervezési minták 1
29;;7;;Melyik kiterjesztési technika rugalmasabb és miért?;;A Template Method, mert az öröklődés erősebb kapcsolatot biztosít;;A Strategy, mert kompozícióra épül és futás közben is cserélhető a viselkedés;;Egyik sem rugalmas, mindkettő statikus viselkedést definiál;;A delegátumok, mert azok nem igényelnek sem interfészt, sem ősosztályt;;B;;Tervezési minták 1
30;;6;;Mi a "Single Responsibility Principle" (SRP) lényege?;;Egy osztálynak csak egyetlen metódusa lehet;;Minden felelősséget egyetlen, nagy osztályba kell szervezni;;Egy osztálynak csak egy oka legyen a változásra (egy felelőssége legyen);;Minden metódus csak egyetlen felelősséget láthat el;;C;;Tervezési minták 1
31;;9;;Melyik a legrugalmasabb megoldás a kiterjeszthetőségre az előadás végén bemutatottak közül?;;Template Method minta, ami öröklődésre épül;;Strategy minta, ami interfész alapú kompozíciót használ;;Delegátumok vagy lambda kifejezések átadása, ami a leglazább csatolást biztosítja;;A kód közvetlen módosítása, mert így teljes a kontroll a változások felett;;C;;Tervezési minták 1
1;;4;;Melyik a létrehozási minták (creational patterns) elsődleges célja?;;A program futásának felgyorsítása;;Az objektumok létrehozásának elrejtése és rugalmassá tétele;;Az osztályok közötti kommunikáció egyszerűsítése;;A felhasználói felület és az üzleti logika szétválasztása;;B;;Tervezési minták 2
2;;5;;Mi a fő probléma a `new` kulcsszóval történő közvetlen objektum-létrehozással, amit a létrehozási minták orvosolnak?;;A `new` operátor használata memóriaszivárgást okoz;;A `new` operátor szorosan köti a kódot egy konkrét implementációhoz, ami rugalmatlan;;A `new` operátor használata nem szálbiztos, és versenyhelyzetet okozhat;;A `new` operátorral létrehozott objektumokat nem lehet tesztelni;;B;;Tervezési minták 2
3;;6;;Mi a Dependency Injection (DI) alapelve?;;Egy osztály maga hozza létre a számára szükséges függőségeket (objektumokat);;Az osztály a függőségeit egy külső forrásból (injektorból) kapja meg, ahelyett, hogy maga hozná létre őket;;Az osztály öröklődés útján jut hozzá a szükséges függőségeihez;;A függőségeket egy globális statikus osztályon keresztül éri el;;B;;Tervezési minták 2
4;;7;;Hogyan segíti a Dependency Injection a unit tesztelést a SecurityService példában?;;Automatikusan generál teszteseteket az adatbázis alapján;;Lehetővé teszi, hogy a valós adatbázis-függőség (DbUserRepository) helyett egy teszt (MemUserRepository) implementációt adjunk át;;A tesztek futását felgyorsítja az adatbázis-kapcsolat cache-elésével;;A tesztek során figyelmen kívül hagyja a függőségeket, és csak a metódus logikáját teszteli;;B;;Tervezési minták 2
5;;5;;Mi a konstruktoron keresztüli injektálás (constructor injection) lényege?;;A függőséget egy setter metóduson keresztül adjuk át az objektumnak;;A függőséget a konstruktor paramétereként kapja meg az objektum;;A függőséget egy interfészen keresztül injektáljuk be;;Az osztály maga kéri el a függőséget a konstruktorában;;B;;Tervezési minták 2
6;;4;;Melyik a Singleton (Egyke) tervezési minta legfőbb célja?;;Lehetővé tenni egy osztály tetszőleges számú példányosítását;;Biztosítani, hogy egy osztályból csak egyetlen példány jöhessen létre, és ehhez globális hozzáférést adni;;Minden objektumot egyetlen központi helyen tárolni a memóriában;;Az objektumok létrehozását egy közös interfész mögé rejteni;;B;;Tervezési minták 2
7;;6;;Hogyan éri el általában a Singleton minta, hogy ne lehessen kívülről példányosítani?;;A `sealed` kulcsszó használatával;;Az osztály konstruktorát `private` vagy `protected` láthatóságúvá teszi;;Egy speciális `[Singleton]` attribútumot használ;;Az osztály minden tagját statikussá teszi;;B;;Tervezési minták 2
8;;5;;Hogyan férhetünk hozzá a Singleton egyetlen példányához a klasszikus megvalósításban?;;Egy `new` operátorral, ami ellenőrzi, hogy létezik-e már a példány;;Egy globális változón keresztül;;Egy statikus `GetInstance()` metóduson vagy `Instance` property-n keresztül;;A Dependency Injection konténer adja oda automatikusan;;C;;Tervezési minták 2
9;;8;;Miért tekinthető a Singleton minta néha anti-patternnek?;;Mert rendkívül lassú a példány lekérése;;Mert elrejti a függőségeket, globális állapotot hoz létre és megnehezíti a unit tesztelést;;Mert túl sok memóriát használ egyetlen példány tárolására;;Mert megsérti az Open/Closed elvet azáltal, hogy nem bővíthető;;B;;Tervezési minták 2
10;;7;;Melyik a bemutatott szálbiztos C# implementációja a Singleton mintának?;;A `GetInstance` metódus `lock`-olása;;Duplán ellenőrzött zárolás (double-checked locking) használata;;Az `instance` változó `volatile`-lá tétele;;A statikus `instance` mező inicializálása a deklaráció helyén;;D;;Tervezési minták 2
11;;5;;Mi az Abstract Factory (Absztrakt gyár) tervezési minta elsődleges célja?;;Egyetlen objektum létrehozására biztosít interfészt, a konkrét típust a leszármazottakra bízva;;Interfészt biztosít egymással összefüggő objektumok családjainak létrehozására, a konkrét osztályok specifikálása nélkül;;Biztosítja, hogy egy osztályból csak egyetlen gyár jöhessen létre;;Egy bonyolult alrendszert egyszerűsít le egyetlen közös interfész mögé rejtve;;B;;Tervezési minták 2
12;;7;;Az Abstract Factory GUI példájában mi a `Win10GUIFactory` szerepe?;;Ez az absztrakt interfész, amit minden konkrét gyárnak implementálnia kell;;Ez a kliens, ami használja a létrehozott vezérlőket;;Ez egy konkrét gyár, ami Win10 stílusú vezérlőket (Window, Button) hoz létre;;Ez egy termék, amit a gyár hoz létre, például egy Win10 ablak;;C;;Tervezési minták 2
13;;8;;Hogyan segíti az Abstract Factory minta a kód függetlenségét a konkrét osztályoktól?;;A kliens csak az absztrakt interfészekkel (AbstractFactory, AbstractProduct) dolgozik, nem ismeri a konkrét implementációkat;;A kliensnek minden konkrét gyár és termék típusát ismernie kell;;A minta használatával a kliensnek nem kell példányosítania semmit, mindent statikusan ér el;;A kliens és a gyár egy köztes, `mediator` objektumon keresztül kommunikál;;A;;Tervezési minták 2
14;;7;;Mi az Abstract Factory minta egyik legnagyobb hátránya?;;Nagyon nehéz új gyár-implementációt (pl. OSX) hozzáadni a rendszerhez;;Nagyon nehéz új terméktípust (pl. ScrollBar) hozzáadni a gyárakhoz, mert az interfész módosításával jár;;A létrehozott termékek szorosan csatolódnak egymáshoz;;A minta használata teljesítményproblémákat okoz a sok indirekció miatt;;B;;Tervezési minták 2
15;;5;;Mire szolgál a Factory Method (Gyártó metódus) tervezési minta?;;Egymással összefüggő objektumcsaládok létrehozására;;Egy objektum létrehozására szolgáló interfészt definiál, de a konkrét osztály kiválasztását a leszármazottakra bízza;;Egy osztály egyetlen példányának létrehozására és elérésére;;Egy meglévő osztály interfészének átalakítására egy másik, a kliens által elvárt interfészre;;B;;Tervezési minták 2
16;;7;;Az `Application`/`Document` példában melyik a Factory Method?;;Az `Application.OpenDocument()` metódus;;Az `Application.CreateDocument()` metódus;;A `TextEditorApplication` konstruktora;;A `Document.Load()` metódus;;B;;Tervezési minták 2
17;;6;;Hogyan hívják gyakran a Factory Method mintát?;;Virtuális Singleton;;Virtuális konstruktor;;Virtuális proxy;;Virtuális interfész;;B;;Tervezési minták 2
18;;8;;Hogyan oldja meg a Factory Method a `DocFx` keretrendszer problémáját, hogy az ne ismerje a `TextDocument` típust?;;A `DocFx` `Application` osztálya a `CreateDocument` hívásával a leszármazott `TextEditorApplication`-re bízza a konkrét `TextDocument` létrehozását;;A `DocFx` reflexióval keresi meg a `TextDocument` osztályt és példányosítja;;A `DocFx` egy `enum` alapján dönti el, hogy milyen dokumentumot hozzon létre;;A `TextDocument` regisztrálja magát a `DocFx` keretrendszernél induláskor;;A;;Tervezési minták 2
19;;5;;Az Observer (Megfigyelő) minta melyik GoF kategóriába tartozik?;;Létrehozási (Creational);;Szerkezeti (Structural);;Viselkedési (Behavioral);;Architekturális (Architectural);;C;;Tervezési minták 2
20;;6;;Mi az Observer minta alapvető célja?;;Lehetővé teszi, hogy egy objektum (subject) állapotváltozásáról automatikusan értesítsen más objektumokat (observer);;Megfigyeli a felhasználói interakciókat és naplózza azokat;;Lehetővé teszi az objektumok aszinkron létrehozását;;Megakadályozza, hogy egy objektum állapota megváltozzon;;A;;Tervezési minták 2
21;;7;;A táblázatkezelős példában miért volt probléma az, hogy a `TableView` közvetlenül hívta a `PieChartView.Update()` metódust?;;Mert ez egy lassú művelet volt;;Mert szoros csatolást (tight coupling) hozott létre a két nézet között, ami megnehezítette a bővítést;;Mert a `PieChartView` nem mindig volt elérhető;;Mert a metódushívás nem volt szálbiztos;;B;;Tervezési minták 2
22;;7;;Az Observer mintával megoldott példában ki a Subject (alany)?;;A `TableView` (táblázatos nézet);;A `PieChartView` (kördiagram nézet);;A `Document` (az adatokat tároló dokumentum);;A felhasználó, aki módosítja az adatokat;;C;;Tervezési minták 2
23;;6;;Hogyan értesíti a Subject az Observereket az állapotának megváltozásáról?;;Az Observerek periodikusan lekérdezik a Subject állapotát;;A Subject meghívja minden regisztrált Observer `Update()` metódusát;;A Subject egy globális eseményt vált ki, amit minden Observer elkap;;Az Observerek a Subject destruktorában kapnak értesítést;;B;;Tervezési minták 2
24;;8;;Hogyan segíti az Observer minta a laza csatolás (loose coupling) elvét?;;A Subject csak egy absztrakt Observer interfészt ismer, nem a konkrét Observer osztályokat;;Az Observerek szorosan ismerik a Subject konkrét implementációját;;A Subject és az Observerek egy közös adatbázison keresztül kommunikálnak;;Minden Observernek ismernie kell az összes többi Observert;;A;;Tervezési minták 2
25;;7;;Melyik .NET nyelvi elem valósítja meg az Observer mintát a nyelv szintjén?;;A `delegate` kulcsszó;;Az `interface` kulcsszó;;Az `event` kulcsszó;;A `[Serializable]` attribútum;;C;;Tervezési minták 2
26;;9;;Mi a különbség a "push" és a "pull" modellek között az Observer mintában?;;A "push" modellben a subject csak jelez, a "pull"-ban az adatot is elküldi;;A "push" modellben a subject elküldi a megváltozott adatot, a "pull"-ban csak jelez, és az observer kéri le az adatot;;A "push" a kliens, a "pull" a szerver oldali megvalósítás;;A "push" szinkron, míg a "pull" aszinkron kommunikációt jelent;;B;;Tervezési minták 2
27;;7;;A bemutatott általános Observer osztálydiagramon mi a ConcreteSubject szerepe?;;Tárolja a megfigyelők listáját és értesíti őket;;Tárolja a konkrét állapotot és értesíti a megfigyelőket, ha az megváltozik;;Definiálja az `Update` interfészt a megfigyelők számára;;Referenciát tárol a Subjectre, hogy lekérdezhesse annak állapotát;;B;;Tervezési minták 2
28;;6;;Mikor használjuk a Factory Method mintát az előadás szerint?;;Amikor egy osztályból csak egyetlen példányt akarunk létrehozni;;Amikor egy osztály nem láthatja előre a létrehozandó objektumok típusát;;Amikor egy meglévő osztályt egy új interfészhez akarunk illeszteni;;Amikor objektumok családjait akarjuk létrehozni;;B;;Tervezési minták 2
29;;8;;Miért jobb a Dependency Injection, mint a Singleton a tesztelhetőség szempontjából?;;Mert a DI gyorsabb kódot eredményez;;Mert a Singleton nem szálbiztos;;Mert a DI lehetővé teszi a függőségek kicserélését teszt-implementációkra (mock/dummy), míg a Singleton statikus `GetInstance` metódusa ezt megnehezíti;;Mert a Singleton több memóriát használ;;C;;Tervezési minták 2
30;;7;;Melyik minta NEM kifejezetten létrehozási minta a felsoroltak közül?;;Abstract Factory;;Factory Method;;Singleton;;Observer;;D;;Tervezési minták 2
31;;8;;A DI-t alkalmazó SecurityService példában hol történik a konkrét `IUserRepository` implementáció (pl. `DbUserRepository`) példányosítása?;;Magában a SecurityService osztályban, a ChangePassword metódusban;;Magában a SecurityService konstruktorában, a `new` operátorral;;A SecurityService osztályon kívül, egy központi helyen (pl. Main), és a konstruktornak adjuk át;;Az IUserRepository interfész definiálja a példányosítást;;C;;Tervezési minták 2
1;;5;;Mi a Command (Parancs) tervezési minta alapvető célja?;;Egy algoritmus vázának definiálása és bizonyos lépések leszármazottakra bízása;;Egy kérés vagy művelet objektumként való egységbe zárása;;Biztosítani, hogy egy osztályból csak egyetlen példány jöhessen létre;;Egy osztály interfészének átalakítása egy a kliens által elvárt másik interfészre;;B;;Tervezési minták 3
2;;6;;A Command minta általános struktúrájában melyik szereplő (participant) indítja el a parancs végrehajtását?;;A Receiver, aki a tényleges munkát végzi;;Az Invoker, aki a parancsot tárolja és meghívja;;A Client, aki létrehozza a parancsot és beállítja a receiver-t;;A ConcreteCommand, aki a saját Execute metódusát hívja;;B;;Tervezési minták 3
3;;6;;A Command minta szövegszerkesztős példájában mi a Receiver szerepe?;;A MenuItem, amire a felhasználó kattint;;A Command interfész, ami az Execute metódust definiálja;;A TextDocument, ami a tényleges műveleteket (pl. vágás, másolás) végrehajtja;;A TextEditorApp, ami a fő alkalmazásablakot képviseli;;C;;Tervezési minták 3
4;;7;;Melyik funkció megvalósítását teszi lehetővé a Command minta, ami a dián is szerepel?;;A parancsok naplózása, sorba állítása és visszavonása (undo);;A parancsok dinamikus betöltése külső fájlokból;;A parancsok automatikus generálása mesterséges intelligencia segítségével;;A parancsok párhuzamosítása több szálon a gyorsabb végrehajtásért;;A;;Tervezési minták 3
5;;6;;Mivel egészíti ki a Command Processor minta a hagyományos Command mintát?;;Új Invoker típusok bevezetésével;;A parancsok visszavonásának (Undo) beépített támogatásával;;A parancsok szerializálásával és hálózaton való küldésével;;A parancsok grafikus felületen való megjelenítésével;;B;;Tervezési minták 3
6;;8;;Hogyan valósítja meg a Command Processor a visszavonást (Undo)?;;Minden parancsnak van egy UnExecute metódusa, a processzor pedig tárolja a lefuttatott parancsokat;;A processzor minden parancs végrehajtása előtt készít egy biztonsági mentést a teljes rendszerről;;A processzor a Memento mintát használja a parancsok állapotának mentésére;;A visszavonás nem lehetséges, a Command Processor csak a parancsok sorba állítására jó;;A;;Tervezési minták 3
7;;7;;A Command Processor példában a CapitalizeCommand miért tárolja el az eredeti szöveget (originalText)?;;Hogy összehasonlíthassa az új szöveggel a változásokat;;Hogy az UnExecute művelet során vissza tudja állítani az eredeti állapotot;;Hogy naplófájlba tudja írni az eredeti és új állapotot;;Hogy ellenőrizze, a felhasználónak van-e joga módosítani a szöveget;;B;;Tervezési minták 3
8;;4;;Mi a Memento (Emlékeztető) tervezési minta legfőbb célja?;;Egy objektum belső állapotának elmentése és visszaállítása az egységbezárás megsértése nélkül;;Egy objektum teljes másolatának (klón) létrehozása;;Egy objektum műveleteinek naplózása egy külső fájlba;;Egy objektum metódusainak időzített végrehajtása;;A;;Tervezési minták 3
9;;6;;A Memento minta szereplői közül melyik a Caretaker (Gondnok)?;;Az az objektum, akinek az állapotát elmentjük (Originator);;Az az objektum, ami magát az állapotot tárolja (Memento);;Az az objektum, aki tárolja a Memento-t, de nem fér hozzá a tartalmához;;Az az objektum, aki elindítja a mentési és visszaállítási folyamatot (Client);;C;;Tervezési minták 3
10;;8;;Hogyan biztosítja a Memento minta az egységbezárás (encapsulation) sértetlenségét?;;Minden állapotváltozót publikussá tesz, hogy a Caretaker elérje;;A Memento-nak szűkített interfésze van a Caretaker felé, de bővített az Originator felé;;A Caretaker öröklődik az Originator-ból, így hozzáfér a védett tagokhoz;;A Memento egy titkosított formában tárolja az adatokat, amit csak az Originator tud visszafejteni;;B;;Tervezési minták 3
11;;7;;A Memento minta példájában a ClearCommand miért működik együtt a Memento-val?;;A ClearCommand hozza létre a TextDocument-et;;Mert a ClearCommand egyben a Caretaker szerepét is betölti, tárolja a törlés előtti állapotot;;Mert a ClearCommand a Memento-t használja az adatok törlésére;;Mert a Memento a ClearCommand-tól kéri el a mentendő adatokat;;B;;Tervezési minták 3
12;;4;;Mi az Adapter (Illesztő) tervezési minta célja?;;Két kompatibilis interfész összekapcsolása;;Egy osztály interfészének átalakítása egy másik, a kliens által elvárt interfészre;;Egy új interfész létrehozása egy meglévő osztályhoz;;Egy bonyolult alrendszer egyszerűsítése;;B;;Tervezési minták 3
13;;6;;Az Adapter minta szereplői közül ki az Adaptee?;;Az interfész, amit a kliens használni szeretne (Target);;Az az osztály, ami implementálja a Target interfészt (Adapter);;Az a meglévő osztály, aminek az interfésze nem megfelelő (Adaptee);;A kliens, ami használni szeretné az Adaptee-t a Target interfészen keresztül;;C;;Tervezési minták 3
14;;7;;Mi a fő különbség az Object Adapter és a Class Adapter között?;;Az Object Adapter öröklődésre, a Class Adapter kompozícióra épül;;Az Object Adapter kompozícióra, a Class Adapter (többszörös) öröklődésre épül;;Az Object Adapter csak objektumokat, a Class Adapter csak osztályokat tud adaptálni;;Az Object Adapter lassabb, de rugalmasabb, míg a Class Adapter gyorsabb, de merevebb;;B;;Tervezési minták 3
15;;7;;A grafikus szerkesztő példában miért volt szükség Adapterre a TextBox-hoz?;;Mert a TextBox túl egyszerű volt, és több funkcionalitásra volt szükség;;Mert a TextBox nem implementálta a Shape interfészt, amit a DrawingEditor elvárt;;Mert a TextBox egy külső, C++-ban írt komponens volt;;Mert a TextBox színét dinamikusan kellett változtatni;;B;;Tervezési minták 3
16;;5;;Melyik a Facade (Homlokzat) tervezési minta legfőbb célja?;;Egy egyszerűsített, egységes interfész biztosítása egy komplex alrendszerhez;;Egy alrendszer minden funkciójának elrejtése a kliens elől;;Egy alrendszer biztonsági réseinek befoltozása;;Az alrendszer komponenseinek egymással való kommunikációjának lehetővé tétele;;A;;Tervezési minták 3
17;;6;;Mi a Facade minta egyik legnagyobb előnye?;;Növeli az alrendszer teljesítményét a hívások optimalizálásával;;Csökkenti a kliens és az alrendszer közötti csatolást (decoupling);;Lehetővé teszi az alrendszer belső működésének módosítását a kliens kódjának megváltoztatása nélkül;;Garantálja, hogy az alrendszerből csak egy példány jöhessen létre;;B;;Tervezési minták 3
18;;4;;Melyik NEM példa a Facade mintára az előadásból?;;Egy több rétegű alkalmazás, ahol az üzleti logikához egy interfészen keresztül férünk hozzá;;A .NET Command osztály;;Egy command-line fordító, ami a belső parsert és tokenizert elrejti;;Operációs rendszerek API-jai;;B;;Tervezési minták 3
19;;5;;Mi a Composite (Összetett) tervezési minta lényege?;;Összetett algoritmusok egyszerűbb lépésekre bontása;;Objektumok fa-struktúrába rendezése, és az elemi (levél) és összetett objektumok egységes kezelése;;Különböző adatbázis-típusok egységes elérésének biztosítása;;A felhasználói felület és az üzleti logika szétválasztása;;B;;Tervezési minták 3
20;;6;;A Composite mintában mi a közös a Leaf (levél) és a Composite (összetett) elemekben?;;Mindkettőnek kötelezően tartalmaznia kell gyerek elemeket;;Mindkettő ugyanazt a Component interfészt valósítja meg;;Mindkettő egyedi, egymással nem kompatibilis metódusokkal rendelkezik;;Mindkettő statikus osztály, amiket nem lehet példányosítani;;B;;Tervezési minták 3
21;;7;;A grafikus példában a Composite minta hogyan teszi lehetővé a rajzolást?;;A DrawAll metódus rekurzívan meghívja a `Draw` metódust minden elemen, legyen az elemi (Line) vagy összetett (Panel);;Külön DrawLine és DrawPanel metódusok léteznek;;A Panel `Draw` metódusa nem csinál semmit, csak a levélelemeké rajzol;;Minden elemnek ismernie kell a szülőjét, és annak a `Draw` metódusát hívja;;A;;Tervezési minták 3
22;;8;;Mi a probléma a Composite mintában a gyerekek kezelésével (Add, Remove)?;;Csak a Leaf elemekhez lehet gyerekeket adni;;Az Add/Remove műveleteknek nincs értelme a Leaf elemeken, ami dilemmát okoz az interfész tervezésekor;;Minden elemhez kötelezően kell gyerekeket hozzáadni;;A gyerekek kezelése rendkívül lelassítja a program futását;;B;;Tervezési minták 3
23;;5;;Mi a Proxy (Helyettes) tervezési minta célja?;;Egy objektum teljes funkcionalitásának lemásolása egy másik objektumba;;Egy helyettesítő vagy `placeholder` objektum biztosítása egy másik objektumhoz való hozzáférés szabályozására;;Két objektum közötti kommunikációs csatorna létrehozása;;Egy objektum állapotának elmentése későbbi visszaállításhoz;;B;;Tervezési minták 3
24;;6;;A Proxy minta szereplői közül melyik a RealSubject?;;A kliens, ami a műveletet kéri;;A Proxy, ami a kérést fogadja;;A tényleges, "valódi" objektum, amihez a Proxy a hozzáférést biztosítja;;A közös interfész, amit a Proxy és a RealSubject is implementál;;C;;Tervezési minták 3
25;;7;;Milyen célt szolgál egy Virtual Proxy?;;A hozzáférés szabályozását jogosultságok alapján (védelmi proxy);;Egy távoli, más címtérben lévő objektum lokális reprezentálását (távoli proxy);;Egy nagy erőforrásigényű objektum létrehozásának késleltetését, amíg arra tényleg szükség nincs (lusta betöltés);;A valódi objektum hívásainak naplózását (naplózó proxy);;C;;Tervezési minták 3
26;;7;;Hogyan működik a Virtual Proxy a képmegjelenítős példában?;;Azonnal betölti a teljes, nagy felbontású képet a memóriába;;Csak a kép méretét tárolja, és a tényleges képadatokat csak akkor tölti be, amikor a `Draw` metódust meghívják;;A kép helyett egy kisebb felbontású előnézeti képet jelenít meg;;Megakadályozza a kép betöltését, ha a felhasználónak nincs jogosultsága;;B;;Tervezési minták 3
27;;8;;Miért fontos, hogy a Proxy és a RealSubject ugyanazt az interfészt (Subject) implementálja?;;Hogy a Proxy örökölhesse a RealSubject implementációját;;Mert ez a C# nyelv szintaktikai követelménye;;Hogy a kliens számára transzparens (átlátszó) legyen, hogy a Proxyval vagy a valódi objektummal kommunikál-e;;Hogy a RealSubject hívni tudja a Proxy metódusait;;C;;Tervezési minták 3
28;;6;;Melyik minta NEM viselkedési minta az előadásban felsoroltak közül?;;Command;;Memento;;Adapter;;Observer;;C;;Tervezési minták 3
29;;7;;Melyik minta NEM szerkezeti minta az előadásban felsoroltak közül?;;Adapter;;Composite;;Facade;;Factory Method;;D;;Tervezési minták 3
30;;8;;Hogyan oldja meg a Command minta a GUI keretrendszer problémáját, ahol egy MenuItem-nek különböző kódokat kell futtatnia?;;Minden MenuItem-ből külön osztályt származtatunk;;A MenuItem-hez egy Command objektumot rendelünk, ami egységbe zárja a végrehajtandó műveletet és a célpontját (Receiver);;A MenuItem egy hosszú `switch` utasítással dönti el, hogy melyik kódot futtassa;;A MenuItem delegátumokat használ a különböző műveletek tárolására;;B;;Tervezési minták 3
31;;9;;Az Adapter és a Facade minta is egy meglévő rendszert "csomagol be". Mi a fő különbség a céljukban?;;Az Adapter egy meglévő interfészt alakít át, míg a Facade egy újat, egyszerűsítettet hoz létre;;A Facade egy meglévő interfészt alakít át, míg az Adapter egy újat, egyszerűsítettet hoz létre;;Az Adapter több alrendszert, a Facade csak egyetlen osztályt egyszerűsít le;;Nincs lényegi különbség, a két minta szinonimája egymásnak;;A;;Tervezési minták 3
1;;3;;Mi a destruktor elsődleges feladata a C++ nyelvben?;;Az objektum tagváltozóinak inicializálása;;Az osztály által dinamikusan lefoglalt memória felszabadítása;;Az objektum állapotának naplózása egy fájlba;;A garbage collector manuális elindítása;;B;;Destruktor, Dispose
2;;4;;Hogyan viselkedik a .NET Garbage Collector (GC) a már nem hivatkozott felügyelt objektumokkal?;;Figyelmen kívül hagyja őket, ami memóriaszivárgáshoz vezet;;Automatikusan felszabadítja a hozzájuk tartozó memóriát;;Kivételt dob, ha egy objektum hivatkozás nélkül marad;;A destruktoruk lefutását várja a memória felszabadításához;;B;;Destruktor, Dispose
3;;6;;Melyik .NET CLR műveletnek felel meg a C# nyelvben definiált destruktor szintaxis (~Osztálynév)?;;A protected override void Finalize() felüldefiniálásának;;Az IDisposable.Dispose() metódus implementálásának;;A System.GC.Collect() metódus meghívásának;;Egy statikus Cleanup() metódus létrehozásának;;A;;Destruktor, Dispose
4;;5;;Melyik állítás NEM igaz a .NET finalizer/destruktor működésére?;;A végrehajtásának pontos ideje nem determinisztikus;;A futási sorrendjük nem garantált több objektum esetén;;A finalizert hívó szál mindig az alkalmazás fő szála;;A destruktorral rendelkező objektumok a finalizer sorba kerülnek;;C;;Destruktor, Dispose
5;;7;;Miért veszélyes egy .NET destruktorban más, felügyelt (managed) objektumokra hivatkozni?;;Mert a fordító ezt szintaktikai hibaként jelzi;;Mert a hivatkozott objektumot a GC már felszabadíthatta;;Mert ez garantáltan holtpontot (deadlock) okoz;;Mert a destruktorban minden hivatkozás csak olvasható;;B;;Destruktor, Dispose
6;;4;;Melyik a tipikus példa a nem felügyelt (unmanaged) erőforrásra?;;Egy C# string objektum;;Egy int típusú tömb;;Egy hálózati kapcsolatot leíró socket handle;;Egy List<string> kollekció;;C;;Destruktor, Dispose
7;;5;;Milyen esetben indokolt destruktort (finalizer) írni egy .NET osztályhoz?;;Ha az osztály nagy méretű felügyelt tömböt kezel;;Ha az osztály közvetlenül kezel nem felügyelt erőforrást;;Minden esetben, ha az osztálynak van konstruktora;;Ha szeretnénk naplózni az objektum megszűnését;;B;;Destruktor, Dispose
8;;7;;Mi a legfőbb hátránya annak, ha kizárólag a destruktorra bízzuk egy fájlkezelő (file handle) lezárását?;;A destruktor túl gyorsan fut le és hibát okozhat;;A fájlkezelő a memóriaszivárgás miatt sosem szabadul fel;;A lezárás nem determinisztikus időpontban történik meg;;A destruktor nem képes fájlkezelőket lezárni;;C;;Destruktor, Dispose
9;;5;;Mit javasol a bevált gyakorlat a System.GC.Collect() metódus használatával kapcsolatban?;;Hívjuk meg minden objektum felszabadítása után;;Használjuk a Dispose minta helyett erőforrások felszabadítására;;Kerüljük a használatát, bízzuk a szemétgyűjtést a CLR-re;;Időzítsük a futását percenként a memória tisztán tartásához;;C;;Destruktor, Dispose
10;;4;;Melyik interfészt kell implementálnia egy osztálynak a determinisztikus erőforrás-felszabadítási minta támogatásához?;;IEnumerable;;IClonable;;IDisposable;;ISerializable;;C;;Destruktor, Dispose
11;;6;;Mi a teendő egy IDisposable interfészt implementáló osztály Dispose metódusában, ha az osztály tartalmaz egy másik IDisposable tagváltozót?;;A tagváltozót null értékre kell állítani;;Meg kell hívni a tagváltozó Dispose() metódusát is;;Várni kell, hogy a GC automatikusan kezelje a tagváltozót;;A tagváltozót a destruktorban kell felszabadítani, nem a Dispose-ban;;B;;Destruktor, Dispose
12;;7;;Miért problémás a `stream.Dispose()` egyszerű meghívása egy metódus végén, kivételkezelés nélkül?;;Mert a Dispose hívás lassú és blokkolhatja a programot;;Mert a metódus korábbi részében dobott kivétel megakadályozza a Dispose lefutását;;Mert a Dispose metódust csak using blokkból szabad hívni;;Mert a JIT fordító optimalizálhatja és kihagyhatja a hívást;;B;;Destruktor, Dispose
13;;4;;Mire szolgál a C# `using` kulcsszava?;;Egy `try-finally` blokkot helyettesít, ahol a `finally` részben hívódik a `Dispose()`;;Egy névteret importál a kódba a könnyebb hivatkozásért;;Egy alias nevet ad egy komplex típusnak;;Kizárólag a `System.IDisposable` típusú változók deklarálására használható;;A;;Destruktor, Dispose
14;;3;;Milyen feltétele van annak, hogy egy objektumot `using` blokkban használhassunk?;;Az osztályának `sealed`-nek kell lennie;;Az osztályának publikus, paraméter nélküli konstruktorral kell rendelkeznie;;Az osztályának implementálnia kell az `IDisposable` interfészt;;Az objektumnak a stack-en kell létrejönnie, nem a heap-en;;C;;Destruktor, Dispose
15;;5;;Melyik beépített .NET osztály NEM implementálja az IDisposable interfészt?;;System.IO.StreamReader;;System.Data.SqlClient.SqlConnection;;System.Drawing.Font;;System.String;;D;;Destruktor, Dispose
16;;6;;Milyen esetben NEM praktikus `using` blokkot használni egy IDisposable objektumra?;;Ha az objektum egy ciklus belsejében jön létre;;Ha az objektum egy osztály tagváltozója, melynek élettartama hosszabb egy metódusnál;;Ha a metódus, amiben használjuk, rekurzív;;Ha az objektumot egy másik metódusnak adjuk át paraméterként;;B;;Destruktor, Dispose
17;;8;;Mi a `GC.SuppressFinalize(this)` hívás célja a `Dispose` metódusban?;;Azonnal elindítja a garbage collector futását;;Megakadályozza, hogy a destruktor (finalizer) feleslegesen lefusson a már "kitakarított" objektumon;;Biztosítja, hogy a destruktor a `Dispose` metódus után fusson le;;Jelzi a CLR-nek, hogy az objektum kritikus fontosságú és nem szabad felszabadítani;;B;;Destruktor, Dispose
18;;9;;A teljes Dispose mintában miért csak akkor szabadítjuk fel a felügyelt erőforrásokat, ha a `dispose(bool isDisposing)` metódus `true` paraméterrel hívódik?;;Mert a destruktorból (`isDisposing = false`) hívva a felügyelt objektumok már lehet, hogy felszabadultak;;Mert a felügyelt erőforrások felszabadítása túl lassú lenne a finalizer szálon;;Mert a CLR tiltja a felügyelt erőforrások módosítását a destruktorban;;Mert a `false` paraméter csak a nem felügyelt erőforrások naplózására szolgál;;A;;Destruktor, Dispose
19;;5;;Hogyan viszonyul egymáshoz a destruktor és a Dispose minta?;;Egymást kizáró, vagy az egyiket vagy a másikat használjuk;;A Dispose a destruktort hívja meg a felszabadításhoz;;A destruktor garantálja az erőforrás felszabadítását, a Dispose pedig determinisztikussá teszi azt;;A Dispose a felügyelt, a destruktor a nem felügyelt erőforrásokért felel;;C;;Destruktor, Dispose
20;;3;;Mi történik a `using` blokkból való kilépéskor az abban deklarált objektummal?;;Az objektum `null` értéket kap;;A CLR azonnal ütemezi a garbage collector futását;;Az objektum `Dispose()` metódusa automatikusan meghívódik;;Semmi különös, az objektum a hatókör végén megsemmisül;;C;;Destruktor, Dispose
21;;6;;Melyik kódrészlet biztosítja garantáltan a `Dispose()` meghívását, még kivétel esetén is (a `using` blokkon kívül)?;;try-catch;;if-else;;try-finally;;while ciklus;;C;;Destruktor, Dispose
22;;8;;A C# 8-ban bevezetett `using` statement (pl. `using var sr = new StreamReader(...)`) mikor hívja meg az `sr` objektum `Dispose` metódusát?;;A következő sor végrehajtása után azonnal;;Amikor a vezérlés elhagyja azt a függvényt vagy blokkot, amiben deklarálták;;Csak akkor, ha a program szabályosan fejeződik be;;Soha, ez a forma nem hívja meg a Dispose metódust;;B;;Destruktor, Dispose
23;;4;;Mi a .NET keretrendszerben a szemétgyűjtő angol, közismert neve?;;Memory Cleaner;;Garbage Collector;;Resource Manager;;Heap Optimizer;;B;;Destruktor, Dispose
24;;7;;Miért lassítja az objektum memóriájának felszabadítását, ha van destruktora?;;Mert a destruktor kódjának elemzése időigényes a JIT fordító számára;;Mert az objektum a finalizer sorba kerül, és egy külön feldolgozási fázison megy keresztül;;Mert a destruktorral rendelkező objektumok a heap egy speciális, lassabb részére kerülnek;;Mert a destruktor lefutása előtt a CLR mindig lefuttat egy teljes szemétgyűjtést;;B;;Destruktor, Dispose
25;;5;;Melyik parancs NEM létezik a C# nyelvben a memória explicit felszabadítására?;;new;;using;;delete;;sizeof;;C;;Destruktor, Dispose
26;;6;;Mi az elsődleges célja annak, hogy a `File` és `StreamReader` osztályok esetén a `Close()` metódus is meghívja a `Dispose()`-t?;;A visszafelé kompatibilitás fenntartása régebbi kódokkal;;Hogy a fejlesztőknek ne kelljen ismerniük a Dispose mintát;;A kód olvashatóságának javítása egy beszédesebb metódusnévvel;;Hogy a fájlt lezárás után azonnal törölni lehessen;;C;;Destruktor, Dispose
27;;9;;A kombinált Dispose/destruktor mintában mi a feladata a `bool isDisposed` tagváltozónak?;;Számolja, hogy hányszor hívták meg a Dispose metódust;;Megakadályozza, hogy a felszabadítási logika többször lefusson;;Jelzi a GC számára, hogy az objektumot sürgősen fel kell szabadítani;;`true` értéknél a destruktor futását engedélyezi;;B;;Destruktor, Dispose
28;;8;;Mi a különbség a `dispose(true)` és a `dispose(false)` hívások között a standard mintában?;;A `dispose(true)` felügyelt és nem felügyelt, a `dispose(false)` csak nem felügyelt erőforrásokat szabadít fel;;A `dispose(true)` szinkron, a `dispose(false)` aszinkron módon fut le;;A `dispose(true)` hívható a felhasználói kódból, a `dispose(false)` csak a CLR belső működéséből;;Nincs funkcionális különbség, csak a hívó kontextusát jelöli;;A;;Destruktor, Dispose
29;;4;;Melyik a helyes szintaxis egy `MyClass` nevű osztály destruktorának deklarálására C#-ban?;;destructor MyClass() { ... };;void MyClass.Finalize() { ... };;~MyClass() { ... };;MyClass.Dispose(false) { ... };;C;;Destruktor, Dispose
30;;6;;Milyen típusú erőforrásokat kell felszabadítani a destruktorban?;;Kizárólag felügyelt (managed) erőforrásokat;;Felügyelt és nem felügyelt erőforrásokat egyaránt;;Kizárólag nem felügyelt (unmanaged) erőforrásokat;;Csak a statikus tagváltozók által lefoglalt memóriát;;C;;Destruktor, Dispose
31;;7;;Mi a `try-finally` blokk használatának hátránya a `using` blokkhoz képest `IDisposable` objektumok esetén?;;Lassabb a futása a `using` blokknál;;Nem garantálja a `Dispose` meghívását kivétel esetén;;Bonyolultabb és több kódot igényel, pl. a null-ellenőrzés miatt;;Nem használható több `IDisposable` objektummal egyszerre;;C;;Destruktor, Dispose
1;;3;;Mi a reláció a relációs adatmodellben?;;Egy, a táblázat sorait leíró séma;;Egy, a táblázat oszlopait leíró séma;;Halmazok Descartes-szorzatának egy részhalmaza;;A táblák közötti fizikai kapcsolat;;C;;Adatbázis
2;;2;;Mit nevezünk attribútumnak a relációs adatmodellben?;;A táblázat egy sorát vagy rekordját;;A táblázat egy oszlopát;;Az egész adatbázis sémáját;;Egy, a táblára vonatkozó megszorítást;;B;;Adatbázis
3;;5;;Melyik állítás NEM igaz a relációs adatmodell szabályaira?;;Egy sor és oszlop kereszteződésében egyetlen érték állhat;;Minden sornak egyedinek kell lennie a táblán belül;;Az oszlopok sorrendje lényeges és megváltoztathatatlan;;A sorok sorrendje lényegtelen;;C;;Adatbázis
4;;6;;Milyen anomália lép fel, ha egy adat módosítása több helyen is szükséges, és egy helyen ez elmarad?;;Beszúrási anomália;;Törlési anomália;;Módosítási anomália;;Lekérdezési anomália;;C;;Adatbázis
5;;6;;Mi a törlési anomália lényege?;;Egy rekord törlésekor a rendszer hibát jelez;;Egy rekord törlésekor nem várt, más adatok is elvesznek;;Nem lehet olyan rekordot törölni amire idegen kulcs hivatkozik;;Egy rekord törlése megváltoztatja a tábla szerkezetét;;B;;Adatbázis
6;;7;;Mit jelent az, hogy a B attribútum funkcionálisan függ az A attribútumtól (A -> B)?;;Az A attribútum értéke megegyezik a B értékével;;Az A attribútum értéke egyértelműen meghatározza a B értékét;;A B attribútum értéke egyértelműen meghatározza az A értékét;;Az A és B attribútumok együtt alkotnak egy kulcsot;;B;;Adatbázis
7;;4;;Mi az elsődleges kulcs (primary key) legfontosabb feladata?;;Egy másik tábla rekordjára való hivatkozás;;A tábla sorainak egyedi azonosítása;;Az adatok titkosítása és védelme;;A lekérdezések gyorsítása indexeléssel;;B;;Adatbázis
8;;4;;Mire szolgál a külső vagy idegen kulcs (foreign key)?;;A tábla sorainak egyedi azonosítására;;Egy másik tábla elsődleges kulcsára való hivatkozásra;;A tábla adatainak titkosítására;;Az adatbázis fizikai tárolási helyének meghatározására;;B;;Adatbázis
9;;5;;Mi a célja az adatbázis-táblák normalizálásának?;;Az adatbázis méretének növelése a gyorsabb elérésért;;Az adatredundancia csökkentése és az anomáliák kiküszöbölése;;Minden adatot egyetlen nagy táblában való elhelyezése;;A felhasználói felület egyszerűsítése;;B;;Adatbázis
10;;6;;Mikor lehet indokolt a denormalizáció, azaz a normalizált struktúra "elrontása"?;;Mindig, mert a normalizálás feleslegesen bonyolult;;Soha, mert az anomáliákhoz vezet;;Ritkán, a lekérdezési teljesítmény javítása érdekében;;Csak kis méretű adatbázisok esetén;;C;;Adatbázis
11;;4;;Melyik SQL parancs tartozik a DML (Data Manipulation Language) kategóriába?;;CREATE TABLE;;ALTER TABLE;;SELECT;;DROP INDEX;;C;;Adatbázis
12;;3;;Melyik SQL parancsot használjuk egy tábla szerkezetének létrehozására?;;INSERT TABLE;;MAKE TABLE;;STRUCTURE TABLE;;CREATE TABLE;;D;;Adatbázis
13;;5;;Mivel definiálunk idegen kulcs kényszert egy oszlopra a CREATE TABLE parancsban?;;A FOREIGN KEY kulcsszóval;;A REFERENCES kulcsszóval;;Az CONNECT TO kulcsszóval;;Az LINK kulcsszóval;;B;;Adatbázis
14;;4;;Melyik SQL parancsot használjuk egy tábla összes sorának törlésére?;;DROP TABLE Termek;;ERASE FROM Termek;;DELETE FROM Termek;;REMOVE ALL Termek;;C;;Adatbázis
15;;5;;Melyik WHERE feltétel választja ki azokat a termékeket, amelyek ára 200 és 300 között van (a határokat is beleértve)?;;WHERE Ar > 200 AND Ar < 300;;WHERE Ar IN (200, 300);;WHERE Ar BETWEEN 200 AND 300;;WHERE Ar >= 200 OR Ar <= 300;;C;;Adatbázis
16;;6;;Hogyan működik az INNER JOIN?;;Minden sort visszaad a bal oldali táblából, és a jobboldaliból a hozzáillőket;;Minden sort visszaad a jobb oldali táblából, és a baloldaliból a hozzáillőket;;A két tábla Descartes-szorzatát adja vissza;;Csak azokat a sorokat adja vissza, ahol az összekapcsolási feltétel mindkét táblában teljesül;;D;;Adatbázis
17;;7;;Miben különbözik a LEFT OUTER JOIN az INNER JOIN-tól?;;A LEFT JOIN gyorsabb, de pontatlanabb eredményt ad;;A LEFT JOIN a bal oldali tábla minden sorát visszaadja, még ha nincs is párja a jobb oldali táblában;;Az INNER JOIN a bal oldali tábla minden sorát visszaadja;;Nincs különbség, a két kulcsszó felcserélhető;;B;;Adatbázis
18;;7;;Hogyan képezzük le adatbázis-táblákra a több-több kapcsolatot (pl. Hallgatók és Tárgyak között)?;;Mindkét táblába felveszünk egy idegen kulcsot a másikra;;Egyetlen közös táblába vonjuk össze a két entitást;;Egy külön kapcsolótábla létrehozásával, ami mindkét tábla elsődleges kulcsát tartalmazza;;A kapcsolatot az alkalmazás kódjában kezeljük, nem az adatbázisban;;C;;Adatbázis
19;;4;;Mi az ADO.NET elsődleges célja?;;Objektum-relációs leképezés (ORM) biztosítása;;Lehetővé teszi .NET alkalmazások számára a relációs adatbázisok elérését;;Egy teljes körű adatbázis-kezelő rendszer;;Egy, a C# nyelvbe épített lekérdezőnyelv;;B;;Adatbázis
20;;5;;Melyik NEM tartozik az ADO.NET kapcsolatalapú adathozzáférés legfontosabb objektumai közé?;;Connection;;Command;;DataReader;;DataSet;;D;;Adatbázis
21;;6;;Mi a `Connection` objektum feladata az ADO.NET-ben?;;SQL parancsok összeállítását és futtatását végzi;;Az adatbázis-kapcsolatot reprezentálja és kezeli;;Egy lekérdezés eredményhalmazán lépked előre;;A kapcsolat nélküli adatok tárolását valósítja meg;;B;;Adatbázis
22;;6;;Melyik `Command` objektum metódust használjuk egy `INSERT` vagy `UPDATE` SQL parancs futtatására?;;ExecuteReader();;ExecuteScalar();;ExecuteNonQuery();;ExecuteCommand();;C;;Adatbázis
23;;7;;Melyik `Command` metódus ad vissza egyetlen értéket, például egy `SELECT COUNT(*)` lekérdezés eredményét?;;ExecuteReader();;ExecuteScalar();;ExecuteNonQuery();;ExecuteSingle();;B;;Adatbázis
24;;5;;Mi a `DataReader` objektum legfontosabb jellemzője?;;Írható és olvasható adatokat tartalmaz;;Lehetővé teszi a visszafelé navigációt az eredményhalmazban;;Gyors, csak előre olvasható (forward-only) hozzáférést biztosít az adatokhoz;;Az adatokat a memóriában tárolja a kapcsolat bontása után is;;C;;Adatbázis
25;;8;;Hogyan védekezhetünk leghatékonyabban az SQL Injection támadások ellen?;;A felhasználói bevitelből kiszűrjük a '- és ; karaktereket;;Sztring összefűzés helyett paraméteres lekérdezéseket használunk;;Az adatbázis-kapcsolatot mindig azonnal bezárjuk;;Kizárólag `ExecuteReader` metódust használunk a parancsok futtatására;;B;;Adatbázis
26;;5;;Miért költséges erőforrás a megnyitott adatbázis-kapcsolat?;;Mert minden kapcsolat sok processzoridőt használ;;Mert az adatbázis-kezelők korlátozzák az egyidejű kapcsolatok számát;;Mert minden nyitott kapcsolat automatikusan zárolja az egész adatbázist;;Mert a nyitott kapcsolatok memóriaszivárgást okoznak a kliens oldalon;;B;;Adatbázis
27;;4;;Melyik SQL parancs felel meg a rekordok módosításának?;;MODIFY;;CHANGE;;UPDATE;;INSERT;;C;;Adatbázis
28;;6;;Az ADO.NET provider modelljében mi a `SqlConnection` és `OracleConnection` osztályok viszonya?;;Egymástól független, alternatív osztályok;;A `SqlConnection` az `OracleConnection` őse;;Mindketten egy közös absztrakt ősosztályból (pl. `DbConnection`) származnak;;Az `OracleConnection` az `SqlConnection` egy aliasa;;C;;Adatbázis
29;;7;;Mi történik, ha egy `SELECT` parancsot az `ExecuteNonQuery` metódussal futtatunk?;;A parancs lefut, de az eredményhalmaz elveszik, a metódus a sorok számát adja vissza;;A parancs szintaktikai hibát okoz fordítási időben;;A parancs futásidejű kivételt (InvalidOperationException) dob;;A parancs lefut, és az első sor első oszlopának értékével tér vissza;;A;;Adatbázis
30;;6;;Mi a "kapcsolatnélküli" (disconnected) adathozzáférési modell lényege?;;Az alkalmazás soha nem csatlakozik az adatbázishoz;;Az adatokat csak a szükséges időre kérdezzük le, majd a kapcsolatot bontjuk;;A felhasználó közvetlenül, alkalmazás nélkül szerkeszti az adatbázist;;Az adatok csak egy helyi fájlban tárolódnak, szinkronizáció nélkül;;B;;Adatbázis
31;;8;;Mi a probléma az SQL parancsok sztringként való összefűzésével felhasználói bemenet alapján?;;Lassú és sok memóriát fogyaszt;;Fordítási hibákhoz vezethet, ha a bemenet idézőjelet tartalmaz;;Lehetőséget ad rosszindulatú SQL kód (SQL Injection) bevitelére;;Nem kompatibilis a legtöbb modern adatbázis-kezelővel;;C;;Adatbázis